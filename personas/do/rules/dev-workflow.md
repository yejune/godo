# Development Workflow Rules [HARD]

## 작업 흐름

### 복잡도 판단 및 워크플로우 선택 [HARD]

- [HARD] 작업 시작 시 복잡도를 판단하여 워크플로우를 선택
- [HARD] **복잡한 작업**: Analysis → Architecture → Plan → Checklist → Develop → Test → Report
- [HARD] **단순한 작업**: Plan → Checklist → Develop → Test → Report
- [HARD] TDD 워크플로우 (단순/복잡 모두 적용 가능): Develop 단계를 Test(RED) → Develop(GREEN) → Refactor로 대체

#### 복잡한 작업 기준 (하나 이상 해당 시 Analysis/Architecture 필수) [HARD]
- [HARD] 5개 이상 파일 변경 예상
- [HARD] 신규 라이브러리/패키지/모듈 생성
- [HARD] 시스템 마이그레이션/전환 (기술 스택 교체, 데이터 이관 등)
- [HARD] 여러 도메인 통합 (backend + frontend + DB 등 3개 이상 도메인)
- [HARD] 추상화 계층 설계 필요 (인터페이스, 프로바이더 패턴, 플러그인 구조 등)
- [HARD] 기존 시스템의 아키텍처 변경 (모놀리스 → 마이크로서비스, 동기 → 비동기 등)

#### 단순한 작업 기준 (모두 해당 시 Analysis/Architecture 생략 가능)
- 4개 이하 파일 변경
- 기존 패턴 내에서의 구현 (새 엔드포인트 추가, 버그 수정 등)
- 단일 도메인 작업
- 아키텍처 변경 없음

#### 판단 불확실 시 [HARD]
- [HARD] 복잡도 판단이 애매하면 사용자에게 질문 (AskUserQuestion): "이 작업은 Analysis/Architecture 단계가 필요할까요?"
- [HARD] 옵션: "예, 분석부터 시작" / "아니요, 바로 플랜"

### Analysis 단계 [HARD]

- [HARD] 목적: 현황 파악 + 요구사항 정리 + 기술 선택지 비교
- [HARD] 담당: analyst 에이전트 (expert-analyst 또는 해당 도메인 expert)
- [HARD] 산출물: `.do/jobs/{YYMMDD}/{title-kebab-case}/analysis.md`
- [HARD] Analysis 완료 전 Architecture 진행 금지

Analysis 에이전트 역할:
1. **현황 조사**: 기존 코드/시스템 역공학, 사용 패턴 분석, 데이터 흐름 추적
2. **요구사항 분석**: 기능 요구사항(MUST/SHOULD/COULD/WON'T) 분류, 비기능 요구사항 식별
3. **기술 선택지 비교**: 후보 라이브러리/접근법 나열, 장단점 분석표 작성
4. **변경 범위 식별**: 영향받는 파일/모듈 목록, 마이그레이션 전략 초안
5. **위험 요소 식별**: 기술적 위험, 호환성 이슈, 성능 영향

### Architecture 단계 [HARD]

- [HARD] 목적: 솔루션 설계 + 인터페이스 명세 + 구현 순서 결정
- [HARD] 담당: architect 에이전트 (expert-backend, expert-frontend 등 해당 도메인)
- [HARD] 입력: analysis.md (Analysis 단계 산출물)
- [HARD] 산출물: `.do/jobs/{YYMMDD}/{title-kebab-case}/architecture.md`
- [HARD] Architecture 완료 전 Plan 진행 금지

Architecture 에이전트 역할:
1. **시스템 구조 설계**: 전체 아키텍처 다이어그램 (ASCII 또는 텍스트), 계층/컴포넌트 관계
2. **디렉토리 구조**: 파일/폴더 트리 설계, 각 파일의 역할 명시
3. **인터페이스 명세**: 핵심 타입/인터페이스 정의 (코드 수준), 컴포넌트 간 계약
4. **구현 상세**: 각 컴포넌트의 내부 로직, 에러 처리 전략, 설정 구조
5. **대안 비교**: 최소 2개 접근법 비교 (선택 이유 + 기각 이유)
6. **구현 순서**: Phase별 구현 순서, 의존성 그래프
7. **위험 완화**: Analysis에서 식별된 위험에 대한 구체적 완화 전략

### 기본 규칙
- [HARD] 플랜 단계에서 사용자에게 TDD 여부 확인 (AskUserQuestion): "TDD로 개발할까요?"
- [HARD] 요구 사항이 모호하면 모든 계획 작성 전에 반드시 명확한 질문 (AskUserQuestion)
- [HARD] 하나의 에이전트는 최대 3개 파일 변경 — 초과 시 작은 작업으로 분해
- [HARD] 체크리스트 항목은 에이전트 토큰 내에서 완료 가능한 크기로 세분화 — 큰 항목은 반드시 쪼갤 것
- [HARD] 요구사항 추가/변경 시 반드시 모든 산출물 업데이트: plan.md → checklist.md → checklists/*.md → report.md
- [HARD] 문서와 실제 작업이 불일치하면 VIOLATION — 문서가 항상 현재 상태를 반영해야 함

### TDD 선택 시 추가 단계 [HARD]
- [HARD] RED: 실패하는 테스트 먼저 작성 — 아직 구현이 없으므로 반드시 실패해야 함
- [HARD] GREEN: 테스트를 통과하는 최소한의 코드 구현 — 과도한 설계 금지
- [HARD] REFACTOR: 테스트 통과 유지하면서 코드 정리 — 동작 변경 금지

### TDD 미선택 시
- 구현 → 검증 순서로 진행
- [HARD] 테스트 가능한 코드 → dev-testing.md 규칙 따름 (행위 기반, FIRST, Real DB 등)
- [HARD] 테스트 불가능한 변경 (CSS, 설정, 문서, 훅 등) → 대안 검증 명시 (빌드 확인, 수동 확인 등)

## 에이전트 위임 시 필수 전달 사항 [HARD]
- [HARD] 에이전트 호출 시 반드시 전달:
  1. 작업 지시 (무엇을 할 것인지)
  2. 서브 체크리스트 파일 경로 (에이전트의 작업 명세서)
  3. Docker 환경 정보 (컨테이너명, 서비스명, 도메인)
  4. **커밋 지시**: "작업 완료 후 반드시 `git add` + `git commit` 수행. 커밋 없이 종료하지 말 것."
- [HARD] 에이전트는 체크리스트를 읽고 작업 범위를 파악한 뒤 개발 시작
- [HARD] 에이전트는 항목 완료 시 체크리스트 상태를 직접 갱신 (`[ ]`→`[~]`→`[*]`→`[o]`)
- [HARD] 체크리스트 = 에이전트 상태 파일 — 진행 상황이 파일에 영속 저장됨
- [HARD] 에이전트는 테스트 통과 후 git 커밋까지 수행 — 커밋 없이 종료는 미완료(incomplete)로 간주
- [HARD] 커밋 메시지는 커밋 규율 섹션의 규칙을 따름 (원자적, WHY 설명)
- [HARD] 오케스트레이터는 에이전트 완료 후 `git status`로 미커밋 변경 확인 — 있으면 에이전트 재호출하여 커밋 수행

## 에이전트 중단 & 재개 [HARD]
- [HARD] 에이전트 토큰 소진/중단 시 오케스트레이터가 체크리스트 확인
- [HARD] `[o]` 완료된 항목은 건너뛰고, `[ ]`/`[~]` 미완료 항목부터 새 에이전트에게 위임
- [HARD] 새 에이전트에게 전달: "이 체크리스트의 미완료 항목부터 이어서 진행하라"
- [HARD] 재개 시에도 동일한 서브 체크리스트 파일 경로 전달 — 연속성 보장

## 에러 대응
- [HARD] 동일 액션 최대 3회 재시도 — 3회 실패 시 중단하고 사용자에게 대안 요청
- [HARD] 무작정 반복 금지 — 같은 방법이 2회 실패하면 접근 방식 자체를 재검토
- [HARD] 에러는 즉시 표면화 — 조용히 삼키거나 무시하지 않음 (Fail Fast)

## 코딩 전 필수 행동 (Read Before Write)
- [HARD] 코드 작성 전 기존 코드를 반드시 읽음 — 읽지 않고 쓰기 금지
- [HARD] 기존 패턴 파악 필수: 네이밍 컨벤션, 에러 처리 방식, 프로젝트 구조
- [HARD] 유사 기능이 이미 존재하는지 확인 — 중복 생성 방지
- [HARD] 새 파일 생성보다 기존 파일 수정 우선 — 파일 비대화 방지
- [HARD] 새로운 추상화는 근거 필요 — 유사 코드 3줄이 조기 추상화보다 낫다 (YAGNI)

## 코딩 규율
- [HARD] 에이전트 검증 레이어: Read(원본 확인) → 수정 → git diff(변경 검증) → 의도한 변경만 확인
- [HARD] 의도치 않은 삭제/변경 발견 시 → 롤백 후 재시도
- [HARD] 단일 책임: 각 변경은 한 가지를 잘 해야 함 — 여러 목적 혼합 금지
- [HARD] 불가능한 시나리오에 에러 핸들링 추가 금지 — 내부 코드는 신뢰, 경계에서만 검증
- [HARD] 변경하지 않은 코드에 주석/독스트링/타입 어노테이션 추가 금지 — diff 노이즈 최소화
- [HARD] 버그 수정 중 주변 코드 "개선" 금지 — 현재 작업에만 집중

## 코딩 후 필수 행동
- [HARD] 코드 작성 후: 무엇이 깨질 수 있는지 나열하고 이를 커버할 테스트 제안
- [HARD] 의미 있는 소단위 커밋 — diff와 메시지만으로 수정 의도 파악 가능
- [HARD] 커밋 전 테스트 통과 확인 — 지침 위반 여부 자가 점검

## 커밋 규율
- [HARD] 원자적 커밋: 하나의 논리적 변경 = 하나의 커밋
- [HARD] 커밋 메시지는 WHY를 설명 — WHAT은 diff가 보여줌
- [HARD] 절대 커밋 금지: .env 파일, 크리덴셜, 대용량 바이너리, 생성된 파일
- [HARD] 커밋 전 자가 점검: "이 diff에 의도한 변경만 포함되어 있는가?"
- [HARD] DO_AI_FOOTER 환경변수에 따라 커밋 메시지 푸터 제어:
  - DO_AI_FOOTER=true: 커밋 메시지 끝에 AI 생성 푸터 추가
  - DO_AI_FOOTER=false (기본값): 푸터 없음
- [HARD] 이 규칙은 개발 에이전트, manager-git 모두에 동일 적용 — Single Source of Truth

## 버그 수정 워크플로우
- [HARD] 재현 우선: 버그를 증명하는 실패 테스트 먼저 작성
- [HARD] 테스트가 통과할 때까지 코드 수정
- [HARD] 회귀 검증: 관련 테스트 스위트 전체 실행으로 사이드이펙트 확인
- [HARD] 재현 테스트 없이 버그 수정 금지
- [HARD] 버그를 잡은 테스트를 삭제해서 "수정"하는 행위 절대 금지

## 지식 관리

### 참조 순서
- [HARD] 1순위: `memory/MEMORY.md` 및 프로젝트 문서 — 이미 알고 있는 지식 먼저
- [HARD] 2순위: 코드베이스 검색 (Grep/Glob) — 기존 패턴과 구현 확인
- [HARD] 3순위: 외부 검색 (WebSearch/Context7) — 위 두 가지로 해결 안 될 때

### 문서화 위치
- [HARD] 작업 중 발견 → 체크리스트 Lessons Learned 섹션 (해당 작업 범위)
- [HARD] 세션 간 재사용할 패턴/삽질 기록 → `memory/MEMORY.md` (시스템 프롬프트에 자동 로드)
- [HARD] 프로젝트 아키텍처 결정/규칙 → 프로젝트 문서 (README, CLAUDE.md, docs/)
- [HARD] "어디에 쓸지" 모르면 → memory에 쓰고 나중에 정리
