# Checklist System Rules [HARD]

## 생성 시점
- [HARD] 플랜 확정 후 반드시 체크리스트 생성 (에이전트 태스크당 1개)
- [HARD] 플랜 없이 체크리스트 생성 금지 — 플랜이 체크리스트의 근거
- PostToolUse hook이 플랜 파일 생성 시 체크리스트 stub을 자동 생성함
- [HARD] 플랜 파일이 존재하고 체크리스트가 stub 상태(미작성)이면, 다른 모든 작업보다 체크리스트 작성을 우선 수행
- [HARD] 체크리스트 작성 절차: 플랜 파일 읽기 → 에이전트별 작업 분해 → 에이전트(Task tool) 호출하여 체크리스트 작성
- [HARD] 항목은 에이전트가 토큰 소진 없이 완료할 수 있는 **아주 작은 단위**로 세분화
- [HARD] 하나의 항목 = 1~3개 파일 변경 + 검증 — 이 범위를 초과하면 쪼갤 것
- [HARD] 검증 방법은 항목별로 명시: 테스트 가능 → 단위/통합 테스트, 테스트 불가 → 빌드 확인/수동 확인/`docker compose config` 등

### 분해 절차 [HARD]
- [HARD] 1단계: 항목 하나가 몇 개 파일을 건드리는지 추정
- [HARD] 2단계: 3파일 초과 → 반드시 분해
- [HARD] 3단계: 분해된 각 항목은 독립적으로 완료/검증 가능해야 함
- [HARD] 4단계: 항목 간 의존성 있으면 `depends on:` 으로 연결
- [HARD] 분해 예시:
  - "API 구현" ← 너무 큼 (5+ 파일)
  - → "라우터 정의" (1파일), "핸들러 구현" (1파일), "검증 로직 추가" (1파일), "에러 응답 처리" (1파일), "단위 테스트" (1파일)
- [HARD] 체크리스트 미작성 상태에서 개발 작업 진행은 VIOLATION

## 작성 방식 [HARD]
- [HARD] jobs 폴더 내 **모든 문서**(checklist.md, report.md, checklists/*.md)는 반드시 에이전트(Task tool)에게 위임
- [HARD] Do/Focus 모드 모두 동일 — 오케스트레이터가 직접 jobs 폴더 파일을 Write/Edit 하지 않음
- [HARD] 이유: 오케스트레이터 컨텍스트 토큰 낭비 방지 — 문서 작성은 에이전트 책임
- [HARD] plan.md만 예외: Plan Mode 훅이 자동 생성/이동 (오케스트레이터가 쓰는 게 아님)

## 체크리스트 = 에이전트 상태 파일 [HARD]
- [HARD] 체크리스트는 단순 문서가 아닌 **에이전트의 영속 상태 저장소**
- [HARD] 에이전트는 작업 시작 시 체크리스트를 읽고 → 작업 범위 파악
- [HARD] 항목 완료할 때마다 체크리스트 상태 갱신 → 진행 상황 파일에 기록
- [HARD] 에이전트 토큰 소진/중단 시 → 체크리스트에 마지막 상태가 남아있음
- [HARD] 새 에이전트가 동일 체크리스트를 받으면 → `[o]` 건너뛰고 미완료 항목부터 재개
- [HARD] 이 패턴으로 **작업 연속성 보장** — 어떤 에이전트든 이어받기 가능

## 파일 구조 (jobs 디렉토리 통합) [HARD]
- [HARD] 하나의 작업 = 하나의 폴더 — 모든 산출물이 같은 디렉토리에 위치:
  - 분석: `.do/jobs/{YYMMDD}/{title-kebab-case}/analysis.md` (복잡한 작업만)
  - 아키텍처: `.do/jobs/{YYMMDD}/{title-kebab-case}/architecture.md` (복잡한 작업만)
  - 플랜: `.do/jobs/{YYMMDD}/{title-kebab-case}/plan.md`
  - 체크리스트: `.do/jobs/{YYMMDD}/{title-kebab-case}/checklist.md`
  - 완료 보고서: `.do/jobs/{YYMMDD}/{title-kebab-case}/report.md`
  - 서브 파일: `.do/jobs/{YYMMDD}/{title-kebab-case}/checklists/{order}_{agent-topic}.md`
- [HARD] 서브 파일의 `{order}`는 두 자리 숫자: `01`, `02`, ... `99`
- 디렉토리 없으면 자동 생성

### 예시 (복잡한 작업)
```
.do/jobs/260211/queue-library-migration/
  ├── analysis.md                    ← 현황 분석 (복잡한 작업)
  ├── architecture.md                ← 아키텍처 설계 (복잡한 작업)
  ├── plan.md                        ← 플랜
  ├── checklist.md                   ← 메인 체크리스트
  ├── report.md                      ← 완료 보고서
  └── checklists/                    ← 에이전트별 서브
      ├── 01_expert-backend.md
      ├── 02_expert-security.md
      └── 03_expert-testing.md
```

### 예시 (단순한 작업)
```
.do/jobs/260211/login-api-security/
  ├── plan.md                        ← 플랜
  ├── checklist.md                   ← 메인 체크리스트
  ├── report.md                      ← 완료 보고서
  └── checklists/                    ← 에이전트별 서브
      ├── 01_expert-backend.md
      └── 02_expert-testing.md
```

## 상태 관리

### 상태 기호
| 기호 | 상태 | 의미 |
|------|------|------|
| `[ ]` | 미시작 (pending) | 아직 작업 시작 안 됨 |
| `[~]` | 진행중 (in progress) | 현재 작업 중 |
| `[*]` | 테스트중 (testing) | 구현 완료, 테스트 검증 중 |
| `[!]` | 블로커 (blocked) | 외부 의존성/결정 대기 중 |
| `[o]` | 완료 (done) | 테스트 통과, 작업 종료 |
| `[x]` | 실패 (failed) | 최종적으로 실패, 더 이상 진행 불가 |

> **주의: 표준 마크다운 체크박스 `[x]`와 혼동 금지**
> 이 상태 기호는 `.do/jobs/` 체크리스트 시스템 전용이다.
> 일반 문서나 스타일 파일의 `- [x]`는 표준 마크다운 "체크됨" 표기이며 별개의 것이다.

### 상태 전이 규칙 [HARD]
- [HARD] 허용된 전이:
  ```
  [ ] → [~]        시작
  [~] → [*]        구현 완료 → 테스트
  [~] → [!]        블로커 발생
  [*] → [o]        테스트 통과 → 완료
  [*] → [~]        테스트 실패 → 재작업 (회귀)
  [*] → [x]        테스트 최종 실패 → 실패
  [~] → [x]        구현 최종 실패 → 실패
  [!] → [~]        블로커 해소 → 재개
  ```
- [HARD] 금지된 전이: `[ ] → [o]` (테스트 없이 완료 불가), `[ ] → [x]` (작업 없이 실패 불가), `[ ] → [*]` (작업 없이 테스트 불가)
- [HARD] 상태 변경 시 히스토리로 기록 (덮어쓰지 않음)

### 블로커 기록 규칙 [HARD]
- [HARD] `[!]` 전환 시 반드시 3가지 기록:
  1. **무엇이** 블로킹하는지 (구체적 이유)
  2. **누가** 해소할 수 있는지 (담당자/외부 시스템)
  3. **언제** 블로킹되었는지 (타임스탬프)

### 상태 히스토리 예시
```
[~] 로그인 API 구현
    - [ ] 2026-02-11 14:00:00 생성
    - [~] 2026-02-11 14:05:12 진행 시작
    - [!] 2026-02-11 15:00:33 블로커: Redis 설정 미완 (담당: infra팀, 해소 대기)
    - [~] 2026-02-11 16:00:05 블로커 해소, 재개
    - [*] 2026-02-11 17:00:41 테스트중
    - [~] 2026-02-11 17:30:18 테스트 실패 (JWT 만료 로직 오류) → 재작업
    - [*] 2026-02-11 18:00:22 재테스트
    - [o] 2026-02-11 18:30:55 완료
```

## 의존성 관리 [HARD]
- [HARD] 항목 간 의존성은 `depends on:` 키워드로 선언
- [HARD] 의존 대상이 미완료면 해당 항목은 자동으로 `[!]` 블로커 취급
- [HARD] 의존성은 메인 체크리스트에서 관리 (서브 파일 간 참조)

### 의존성 표기법
```
## 작업 목록
- [o] #1 DB 스키마 마이그레이션
- [~] #2 로그인 API 구현 (depends on: #1)
- [ ] #3 프론트엔드 로그인 폼 (depends on: #2)
- [!] #4 소셜 로그인 연동 (depends on: #2, 블로커: OAuth 키 미발급)
```

## 서브 체크리스트 템플릿 [HARD]

각 서브 파일(`{order}_{agent-topic}.md`)은 다음 섹션을 포함:

```markdown
# {agent-topic}: {작업 제목}
상태: [ ] | 담당: {에이전트}

## Problem Summary
- 무엇을 해결하는가
- 왜 이 작업이 필요한가

## Acceptance Criteria
- [ ] 측정 가능한 완료 조건 1
- [ ] 측정 가능한 완료 조건 2
- [ ] 검증 완료 (아래 중 해당하는 방식):
  - 테스트 필요: `path/to/file_test.go` 작성 및 통과
  - 테스트 불필요: 검증 방법 명시 (빌드 확인, 수동 확인 등)
- [ ] 커밋 완료

## Solution Approach
- 선택한 접근 방식
- 왜 이 방식인가 (고려한 대안과 기각 이유)

## Critical Files
- **수정 대상**: `path/to/file.go` -- 변경 이유
- **참조 파일**: `path/to/ref.go` -- 참조 이유
- **테스트 파일**: `path/to/file_test.go`

## Risks
- 깨질 수 있는 것: (구체적으로)
- 주의할 점: (사이드이펙트, 성능, 호환성)

## Progress Log
- 2026-02-11 14:00:00 [~] 작업 시작: 초기 구조 설계
- 2026-02-11 15:30:22 [~] JWT 토큰 발급 로직 구현 완료
- 2026-02-11 16:00:45 [*] 단위 테스트 작성 및 실행
- 2026-02-11 16:30:10 [o] 모든 테스트 통과, 커밋 완료 (commit: a1b2c3d)

## FINAL STEP: Commit (절대 생략 금지)
- [ ] `git add` — 변경된 파일만 스테이징
- [ ] `git diff --cached` — 의도한 변경만 포함되었는지 확인
- [ ] `git commit` — 커밋 메시지에 WHY 포함
- [ ] 커밋 해시를 Progress Log에 기록
⚠️ 이 섹션을 완료하지 않으면 작업은 미완료(incomplete) 상태임

## Lessons Learned (완료 시 작성)
- 잘된 점:
- 어려웠던 점:
- 다음에 다르게 할 점:
```

### 템플릿 필수 규칙
- [HARD] Problem Summary, Acceptance Criteria, Critical Files는 작업 시작 전 반드시 작성
- [HARD] Acceptance Criteria에 검증 방법 필수 명시 — 테스트 파일 경로 또는 대안 검증 방법
- [HARD] 에이전트는 코드 작성 → 검증(테스트/빌드) → 통과 → 커밋까지가 한 세트 — 코드만 쓰고 끝내기 금지
- [HARD] 커밋 후 Progress Log에 커밋 해시 기록 필수 — 예: `[o] 완료 (commit: a1b2c3d)`
- [HARD] 커밋 해시 없는 `[o]` 완료 전환 금지 — 커밋이 곧 완료의 증거
- [HARD] Solution Approach는 구현 시작 시 작성 (대안 최소 1개 언급)
- [HARD] Progress Log는 상태 변경뿐 아니라 **무엇을 했는지** 기록 (작업 내용 추적)
- [HARD] Progress Log 타임스탬프는 초 단위 포함 필수: `YYYY-MM-DD HH:MM:SS` — 동일 분에 여러 상태 변경 시 구분 가능
- [HARD] 동일 타임스탬프에 여러 상태 전이 금지 — 각 단계는 실제 작업 시점을 반영
- [HARD] Lessons Learned는 `[o]` 완료 전환 시 반드시 작성 -- 빈 칸 금지
- Risks는 식별된 것이 없으면 "식별된 리스크 없음" 기재

## 체크리스트 표시 의무 [HARD]

- [HARD] 모든 작업이 완료되면 오케스트레이터는 반드시 체크리스트 현재 상태를 사용자에게 표시
- [HARD] 표시 형식: 각 항목의 상태 기호(`[o]`/`[x]`/`[~]`/`[ ]`/`[!]`) + 한 줄 요약
- [HARD] 미완료 항목이 있으면 다음 행동 제안 (재개 or 사용자 결정 요청)
- [HARD] Stop hook이 활성 체크리스트 감지 시 종료를 차단 — 체크리스트 표시 후 종료 가능

## 완료 보고 [HARD]

- [HARD] 모든 체크리스트 완료 시 해당 job 폴더의 `report.md`에 최종 완료 보고서 작성

### 완료 보고서 템플릿
```markdown
## 완료 보고서

### 실행 요약
- 완료: {N}/{M} 태스크 (예: 3/3)
- 기간: {시작일시} ~ {종료일시}

### 플랜 대비 변경사항
- (원래 계획과 달라진 점, 왜 변경했는지)
- (변경 없으면 "플랜대로 진행")

### 테스트 결과
- 전체: {pass}/{total} 통과
- 커버리지: {N}% (측정 가능한 경우)
- 실패/스킵: 없음 또는 상세 내역

### 변경 파일 요약
- `path/to/file.go` -- 변경 내용 한 줄 요약
- `path/to/test.go` -- 추가된 테스트

### 미해결 사항
- (후속 작업이 필요한 항목)
- (알려진 제약사항)
- (없으면 "없음")

### 핵심 교훈
- (서브 태스크 Lessons Learned 종합)
- (팀/프로젝트에 공유할 인사이트)
```

### 완료 보고 규칙
- [HARD] report.md 작성 시 checklist.md와 checklists/*.md를 참조하여 종합
  - 실행 요약 ← checklist.md 상태 집계
  - 핵심 교훈 ← 각 서브 체크리스트의 Lessons Learned 종합
  - 변경 파일 ← 각 서브 체크리스트의 Critical Files + `git diff --stat`
- [HARD] `미해결 사항`이 있으면 후속 플랜 또는 이슈로 등록
- [HARD] 테스트 결과에 실패가 있으면 완료 보고 금지 — 먼저 해결
- [HARD] 변경 파일 요약은 `git diff --stat`과 일치해야 함

---

## Analysis 문서 템플릿 [HARD]

복잡한 작업 시 `.do/jobs/{YYMMDD}/{title-kebab-case}/analysis.md`에 작성.
dev-workflow.md의 복잡도 기준 참조.

```markdown
# {작업 제목} 분석

**분석 일시**: {YYYY-MM-DD}
**대상 프로젝트**: {프로젝트명}
**검토 범위**: {분석 대상 범위}

---

## 1. 현재 시스템 분석

### 1.1 구성 요소

| 항목 | 값 |
|------|-----|
| **핵심 모듈** | (모듈/서비스명) |
| **기술 스택** | (언어, 프레임워크, 라이브러리) |
| **데이터 저장소** | (DB, 캐시, 파일 시스템 등) |
| **외부 의존성** | (서드파티 API, 서비스 등) |

### 1.2 데이터 흐름 / 핵심 로직

(현재 시스템의 데이터 흐름, 상태 머신, 핵심 비즈니스 로직을 코드 스니펫과 함께 설명)

### 1.3 현재 설정 / 인프라

(docker-compose, 환경변수, 연결 설정 등 인프라 관련 현황)

---

## 2. 변경 범위 분석

### 2.1 변경이 필요한 영역

(각 영역별로 현재 코드 → 변경 후 코드 비교)

### 2.2 유지해야 할 것

(변경 범위와 무관하게 보존해야 할 비즈니스 로직, 데이터 구조, 계약 등)

### 2.3 현재 기능 중 대상 기술에서 미지원 항목

| 기능 | 현재 | 대상 | 마이그레이션 방식 |
|------|------|------|-----------------|
| (기능명) | (현재 지원 여부) | (대상 지원 여부) | (대안 또는 직접 구현) |

---

## 3. 요구사항 정리

### 3.1 필수 기능 (MUST)

| 기능 | 설명 | 우선순위 |
|------|------|---------|
| (기능명) | (설명) | P0/P1 |

### 3.2 권장 기능 (SHOULD)

| 기능 | 설명 | 대체 방식 |
|------|------|---------|
| (기능명) | (설명) | (대안이 있다면) |

### 3.3 선택 기능 (COULD)

| 기능 | 설명 | 제외 이유 |
|------|------|---------|
| (기능명) | (설명) | (v1 범위 밖인 이유) |

### 3.4 제외 기능 (WON'T)

| 기능 | 이유 |
|------|------|
| (기능명) | (제외 사유) |

---

## 4. 기술 선택지 비교

### 4.1 후보 목록

| 후보 | 타입 | 장점 | 단점 |
|------|------|------|------|
| (후보 A) | (유형) | (장점) | (단점) |
| (후보 B) | (유형) | (장점) | (단점) |

### 4.2 권장 선택: {선택한 후보}

**이유:**
- (선택 근거 1)
- (선택 근거 2)

---

## 5. 마이그레이션 전략

### 5.1 단계별 전환

| 단계 | 내용 | 영향 범위 |
|------|------|---------|
| Phase 1 | (내용) | (영향 범위) |
| Phase 2 | (내용) | (영향 범위) |

### 5.2 위험 요소 및 완화책

| 위험 | 영향도 | 완화책 |
|------|--------|--------|
| (위험 설명) | HIGH/MEDIUM/LOW | (완화 방법) |

---

## 6. 결론

### 핵심 변경점 요약
1. (변경점 1)
2. (변경점 2)

### 권장 구현 전략
1. (전략 1)
2. (전략 2)

---

**작성자**: {에이전트명}
**검토 상태**: 분석 완료
**다음 단계**: Architecture 설계
```

### Analysis 템플릿 규칙
- [HARD] 섹션 1(현재 시스템 분석)은 코드 역공학 기반 — 추측이 아닌 실제 코드에서 추출
- [HARD] 섹션 3(요구사항)은 MoSCoW 분류법 사용 (MUST/SHOULD/COULD/WON'T)
- [HARD] 섹션 4(기술 선택지)는 최소 2개 후보 비교 필수
- [HARD] 섹션 5(위험 요소)는 영향도(HIGH/MEDIUM/LOW) 명시 필수
- [HARD] 모든 코드 스니펫은 실제 프로젝트 코드에서 발췌 — 가상 코드 금지
- 프로젝트 특성에 따라 섹션 추가/축소 가능하나 위 핵심 섹션은 유지

---

## Architecture 문서 템플릿 [HARD]

복잡한 작업 시 `.do/jobs/{YYMMDD}/{title-kebab-case}/architecture.md`에 작성.
analysis.md 완료 후 작성. dev-workflow.md의 복잡도 기준 참조.

```markdown
# {작업 제목} Architecture Design

## Overview

(1-2문장 요약: 무엇을, 왜, 어떻게)

(ASCII 아키텍처 다이어그램)

---

## 1. Directory Structure

(파일/폴더 트리 — 각 파일의 역할 주석 포함)

---

## 2. Core Interfaces

(핵심 타입, 인터페이스, 계약을 코드 수준으로 정의)

(각 인터페이스에 JSDoc/docstring 스타일 설명 포함)

---

## 3. Error Handling

(에러 계층 구조, 에러 코드 enum, 에러 래핑 전략)

---

## 4. Component Implementations

### 4.1 {컴포넌트 A}

(구현 상세: 클래스/함수 시그니처, 내부 로직, 설정 매핑)

### 4.2 {컴포넌트 B}

(구현 상세)

---

## 5. Integration Layer

(프레임워크 통합, DI 설정, 모듈 구조 등)

---

## 6. Configuration

### 6.1 Package/Build Configuration

(package.json, tsconfig, build tool 설정 등)

### 6.2 Public API

(외부에 노출하는 인터페이스, re-export 구조)

---

## 7. Approach Comparison

### Approach A: {접근법 이름} (권장)

(설명)

| 항목 | 평가 |
|---|---|
| 복잡도 | (낮음/중간/높음) |
| 확장성 | (평가) |
| 테스트 용이성 | (평가) |

### Approach B: {대안 접근법}

(설명 + 기각 이유)

### 결론: {선택한 접근법} 선택

(선택 근거 요약)

---

## 8. Testing Strategy

### Unit Tests
(mock 기반 단위 테스트 대상 및 예시)

### Integration Tests
(실제 인프라 연동 테스트 대상 및 예시)

### Test Matrix

| Layer | Method | Infrastructure |
|---|---|---|
| (계층) | (테스트 유형) | (필요 인프라) |

---

## 9. Implementation Order

(Phase별 구현 순서, 파일 단위로 번호 매기기)

---

## 10. Risk Mitigation

| Risk | Impact | Mitigation |
|---|---|---|
| (위험) | (영향) | (완화책) |
```

### Architecture 템플릿 규칙
- [HARD] Overview에 ASCII 다이어그램 필수 — 시스템 구조를 시각적으로 표현
- [HARD] Core Interfaces는 실제 구현 가능한 코드 수준으로 작성 — 의사코드 금지
- [HARD] Approach Comparison에 최소 2개 접근법 비교 필수 — 선택 근거 명시
- [HARD] Implementation Order는 파일 단위로 번호를 매겨 Plan/Checklist로 직접 변환 가능하게
- [HARD] Testing Strategy에 Unit/Integration 구분 필수 — 테스트 대상 파일 경로 포함
- [HARD] analysis.md의 요구사항(MUST/SHOULD)이 architecture.md에 모두 반영되었는지 교차 확인
- 프로젝트 특성에 따라 섹션 추가/축소 가능하나 위 핵심 섹션은 유지
