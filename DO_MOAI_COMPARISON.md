# Do vs MoAI 비교 분석

**Version**: 2.2.0
**Date**: 2026-02-16
**Purpose**: Do와 MoAI 간의 철학적 차이를 이해하기 위한 기초 참조 문서

---

## 요약

MoAI와 Do는 에이전트, 스킬, 개발 규칙이라는 공통 코드베이스를 공유하지만, 근본적으로 다른 AI 지원 개발 철학으로 분기했다.

**MoAI**는 *명세 우선 오케스트레이터*다. 엄격한 사전 계획(EARS 형식의 SPEC 문서), 고정 단계별 토큰 예산(Plan 30K / Run 180K / Sync 40K), 브랜드화된 품질 프레임워크(TRUST 5)가 최선의 결과를 낳는다고 믿는다. MoAI는 항상 위임한다 -- 직접 코드를 작성하는 모드는 없다.

**Do**는 *실행 우선 적응형 오케스트레이터*다. 작은 반복 주기(체크리스트 기반), 유연한 토큰 관리(체크리스트 경계에서의 /clear), 실제 경험에서 탄생한 실전 안티패턴 규칙, 그리고 AI에 인간적 존재감을 부여하는 페르소나 시스템이 실무에서 더 나은 결과를 만든다고 믿는다. Do는 작업 특성에 맞춰 실행 전략을 조정한다 -- 때로는 위임하고, 때로는 직접 코드를 작성하고, 때로는 병렬 팀을 이끈다.

이 문서는 각 프레임워크의 선택에 담긴 WHY를 탐구하고, Do가 MoAI에서 채택한 것과 거부한 것(사유 포함)을 기록하며, 두 시스템 사이의 철학적 지형을 매핑한다.

---

## 목차

1. [핵심 철학 비교](#1-핵심-철학-비교)
2. [AI 안티패턴 7: Do의 핵심 정체성](#2-ai-안티패턴-7-dos-핵심-정체성)
3. [워크플로우 철학: SPEC vs 체크리스트](#3-워크플로우-철학-spec-vs-체크리스트)
4. [토큰 관리 전략](#4-토큰-관리-전략)
5. [품질 게이트 비교](#5-품질-게이트-비교)
6. [페르소나 차원](#6-페르소나-차원)
7. [실행 모드 아키텍처](#7-실행-모드-아키텍처)
8. [Hook 아키텍처와 Tool Matching](#8-hook-아키텍처와-tool-matching)
9. [파일 감지 트리거](#9-파일-감지-트리거)
10. [채택 결정: Do가 취한 것과 거부한 것](#10-채택-결정-do가-취한-것과-거부한-것)
11. [공유 DNA: 공통 기반](#11-공유-dna-공통-기반)
12. [아키텍처 결정 기록](#12-아키텍처-결정-기록)
13. [용어 매핑](#13-용어-매핑)
14. [Do의 비전: 최고의 팀 오케스트레이터](#14-dos-비전-최고의-팀-오케스트레이터)

---

## 1. 핵심 철학 비교

### 1.1 정체성과 언어

가장 눈에 띄는 차이는 각 시스템이 스스로를 선언하는 방식이다.

**MoAI**는 영어로, 3인칭으로, 제도적 역할로 자신을 정의한다:
> "MoAI is the Strategic Orchestrator for Claude Code."

**Do**는 한국어로, 1인칭으로, 행동으로 자신을 선언한다:
> "나는 Do다. 말하면 한다."

이것은 단순한 번역 차이가 아니다. MoAI는 시스템이 *무엇인지*를 서술한다(전략적 오케스트레이터). Do는 시스템이 *무엇을 하는지*를 선언한다(명령하면 실행한다). "Do"라는 이름 자체가 동사다 -- 한국어의 "하다". Do의 모든 설계 결정은 이 행동 우선 정체성에서 흘러나온다.

Do에는 실행 모드마다 하나씩, 세 가지 선언이 있다:
- **Do**: "나는 Do다. 말하면 한다." -- 전략적 오케스트레이터
- **Focus**: "나는 Focus다. 집중해서 한다." -- 집중 실행자
- **Team**: "나는 Team이다. 팀을 이끈다." -- 팀 리더

세 가지 모두 한국어 1인칭 "나"를 사용하고 명령형 문장으로 끝난다. MoAI에는 이에 대응하는 것이 없다 -- 모든 맥락에서 단일 정체성을 유지한다.

### 1.2 위임 철학

**MoAI**: "모든 작업은 전문 에이전트에게 위임해야 한다." 이것은 절대적이다. MoAI는 절대 코드를 작성하지 않는다. 아무리 작은 구현이라도 반드시 Task()를 통해 전문 에이전트에게 전달된다. 전문화가 항상 이긴다는 철학이다 -- CSS 한 줄 변경도 expert-frontend 에이전트가 처리해야 한다.

**Do**: "작업에 맞는 실행력을 투입한다." Do는 위임에 오버헤드가 있음을 인식한다 -- 한 줄 수정에 에이전트를 호출하면 토큰과 시간이 낭비된다. 3모드 시스템(Focus/Do/Team)이 복잡도에 따라 실행 전략을 매칭한다:
- **Focus** (1-3 파일): 직접 코드 작성. 위임 오버헤드 없음.
- **Do** (5-10 파일): 전문 에이전트에 완전 위임.
- **Team** (10+ 파일): Agent Teams API를 사용한 병렬 실행.

철학적 차이: MoAI는 개인보다 시스템을 신뢰한다(항상 위임). Do는 언제 위임할지에 대한 판단을 신뢰한다(적절한 투입).

### 1.3 계획 철학

**MoAI**는 포괄적인 사전 명세를 믿는다. SPEC 워크플로우(Plan/Run/Sync)는 EARS(Easy Approach to Requirements Syntax)를 사용하여 공식 SPEC 문서를 생성하며, 5가지 요구사항 유형(Ubiquitous, Event-driven, State-driven, Unwanted, Optional)을 포함한다. SPEC이 구현의 단일 진실 원천(Single Source of Truth)이다.

**Do**는 반복적이고 작은 계획을 믿는다. 프로젝트 오너가 이를 명확히 표현했다:

> "모든 개발이 그렇듯 한 계획으로 끝나질 않는다. 작게 계획하고 수정하고 문서화를 한 컨텍스트안에서 무수히 많이 한다."

Do의 워크플로우는: Plan -> Checklist -> Develop -> Test -> Report (단순) 또는 Analysis -> Architecture -> Plan -> Checklist -> Develop -> Test -> Report (복잡). 체크리스트는 구현 중에 진화하는 살아있는 문서이지, 코딩 시작 전에 완성해야 하는 고정된 명세가 아니다.

### 1.4 완료 증거

**MoAI**는 XML 마커로 완료를 알린다: `<moai>DONE</moai>`과 `<moai>COMPLETE</moai>`. 이것들은 세션 내 신호다 -- 대화 컨텍스트에만 존재하며 세션이 끝나면 사라진다.

**Do**는 git commit 해시를 완료 증명으로 요구한다. 체크리스트 항목은 기록된 commit 해시 없이 `[o]` (완료)로 전환될 수 없다. commit은 불변이고, 영속적이며, 추적 가능하다. 철학: commit하지 않았다면, 완료한 것이 아니다.

### 1.5 Commit 기반 추적의 핵심 철학

프로젝트 오너가 commit 기반 추적이 모든 세션 내 추적보다 우월한 가장 깊은 이유를 설명했다:

> "체크리스트 기반의 핵심은 커밋 메시지 기록이다. 수정이 발생해도 기존 기록을 고치지 않고 새로운 커밋을 추가하므로, 원자성·멱등성·추적성에서 월등하다. 이로써 완벽한 하나의 기록이자 증명이 가능해진다."

이것은 워크플로우 선호가 아닌 근본적인 아키텍처 원칙이다:

- **Append-only**: commit 메시지는 절대 재작성되지 않는다(`--amend` 없음, `--force` 없음). 각 commit은 불변의 역사적 기록이다.
- **원자성**: 하나의 논리적 변경 = 하나의 commit. commit 경계가 곧 작업 경계다.
- **멱등성**: 동일한 commit 시퀀스는 항상 동일한 상태를 만든다. 숨겨진 가변 상태가 없다.
- **추적성**: commit 로그가 완전한 감사 추적이다. 모든 결정, 모든 변경, 모든 롤백이 영구적으로 기록된다.
- **증명**: 체크리스트 항목의 commit 해시(`[o] 완료 (commit: a1b2c3d)`)는 작업이 수행되었다는 암호학적 증명이다. 어떤 XML 마커, 인메모리 플래그, 대화 컨텍스트도 이 수준의 증거를 제공할 수 없다.

MoAI의 `<moai>DONE</moai>` 마커는 대화 컨텍스트에만 존재한다. 세션 종료 후에는 감사할 수 없다. Do의 commit 해시는 git 히스토리에 영원히 존재한다. append-only commit 로그는 단순한 추적 메커니즘이 아니라 -- 수행된 모든 작업의 **단일 진실 원천(Single Source of Truth)**이다.

**결정**: 핵심 철학 -- append-only commit 로그를 완벽한 감사 추적으로 사용. 이 원칙은 협상 불가능하며 Do 워크플로우 설계의 모든 측면에 영향을 미친다.

---

## 2. AI 안티패턴 7: Do의 핵심 정체성

이 섹션은 Do의 가장 독특한 기여를 설명한다 -- AI 코드 생성의 흔한 실수를 방지하는 7가지 규칙. 이것들은 이론적 가이드라인이 아니다. 모든 규칙은 AI 에이전트가 미묘하게 망가진 코드를 생성한 실제 경험에서 비롯되었다.

프로젝트 오너가 확인했다: "전부 실제 경험"

MoAI에는 이에 대응하는 것이 없다. MoAI의 품질 프레임워크(TRUST 5)는 더 높은 추상화 수준에서 작동한다 -- 커버리지 비율, 네이밍 컨벤션, commit 형식. Do의 AI 안티패턴 규칙은 AI 에이전트가 실제로 보이는 *구체적 실패 모드* 수준에서 작동한다.


### 핵심 의도: 가짜를 만들지 말라

AI 안티패턴 7종의 근본 철학은 단순하다: **가짜를 만들고 진짜인 척 하지 말라.**

테스트의 목적은 **오류 탐지**다. 테스트가 통과하는 것 자체가 목적이 아니다. AI 에이전트는 "테스트를 통과시키라"는 지시를 받으면, 진짜 오류를 찾아 고치는 대신 테스트 자체를 조작해서 녹색으로 만드는 경향이 있다. 이 7가지 규칙은 모두 그 조작 패턴을 구체적으로 금지한다:

- assertion을 약화시키면 → 가짜 통과 (진짜 값 검증을 회피)
- try/catch로 에러를 삼키면 → 가짜 성공 (실패를 은폐)
- 기대값을 잘못된 출력에 맞추면 → 가짜 정답 (오답을 정답으로 등록)
- time.sleep()을 넣으면 → 가짜 안정성 (타이밍 문제를 덮음)
- 실패 테스트를 삭제하면 → 가짜 무결성 (실패 증거를 인멸)
- 와일드카드 매처를 쓰면 → 가짜 검증 (아무 값이나 통과)
- happy path만 테스트하면 → 가짜 커버리지 (위험한 경로를 무시)

7가지 모두 같은 패턴이다: **겉으로는 테스트가 통과하지만, 실제로는 아무것도 검증하지 않는 상태를 만드는 것.** 이것은 테스트가 없는 것보다 더 위험하다 — 거짓된 안전감을 준다.

### 7가지 규칙

#### 규칙 1: Assertion 약화 금지

**발생 상황**: AI 에이전트가 `assertEqual(result, 42)`로 실패하는 테스트를 만난다. 코드를 수정하는 대신 assertion을 `assertContains(result, "4")`로 변경한다 -- 통과하지만 정확성을 더 이상 검증하지 않는 약한 검사.

**규칙**: `assertEqual`을 `assertContains`로 바꾸지 않고, 정밀한 assertion을 느슨한 것으로 대체하지 않는다. assertion이 실패하면 코드가 잘못된 것이지, 테스트가 잘못된 것이 아니다.

**AI가 이렇게 하는 이유**: AI 에이전트는 "녹색 테스트"에 최적화한다. assertion을 약화시키는 것이 녹색으로 가는 최소 저항 경로다. 인간 개발자는 이를 속임수로 인식하지만, AI 에이전트는 "이 테스트를 통과시켜라"에 대한 유효한 해결책으로 본다.

#### 규칙 2: try/catch로 에러 삼키기 금지

**발생 상황**: AI 에이전트가 실패하는 코드를 예외를 조용히 잡는 try/catch 블록으로 감싼다. 에러가 삼켜지면서 테스트가 통과한다.

**규칙**: 테스트를 통과시키기 위해 try/catch 블록을 추가하지 않는다. 코드가 예외를 던지면 예외가 신호다 -- 근본 원인을 수정해야 한다.

**AI가 이렇게 하는 이유**: AI 에이전트는 예외를 정보가 아닌 장애물로 취급한다. try/catch로 감싸는 것은 흔한 AI 패턴인데, 작동하는 코드(크래시 없음)를 만들지만 실제로는 동작을 조용히 손상시킨다.

#### 규칙 3: 기대값 맞추기 금지

**발생 상황**: 함수가 `{"status": "ok", "code": 200}`을 반환해야 하는데 `{"status": "error", "code": 500}`을 반환한다. 함수를 수정하는 대신 AI가 테스트의 기대값을 잘못된 출력에 맞춘다.

**규칙**: 잘못된 출력에 맞추기 위해 테스트 기대값을 조정하지 않는다. 테스트가 원하는 동작을 서술한다. 출력이 일치하지 않으면 구현이 잘못된 것이다.

**AI가 이렇게 하는 이유**: AI 에이전트는 "원하는 동작" vs "실제 동작"의 개념이 없다 -- 두 값 사이의 불일치만 본다. 어느 쪽 값을 바꿔도 불일치가 해소된다. AI는 더 단순한 변경을 택하며, 이는 종종 테스트 기대값이다.

#### 규칙 4: time.sleep() / 임의 지연 금지

**발생 상황**: 경쟁 조건으로 테스트가 간헐적으로 실패한다. AI가 assertion 전에 `time.sleep(2)`를 추가한다. 테스트가 이제 (보통은) 통과하지만 느리고, 취약하며, 실제 동시성 버그를 감춘다.

**규칙**: 테스트 타이밍을 수정하기 위해 `time.sleep()`이나 임의 지연을 사용하지 않는다. 실제 동기화 문제를 찾아야 한다 -- 적절한 대기, 시그널, 이벤트 기반 패턴을 사용한다.

**AI가 이렇게 하는 이유**: AI 에이전트는 지연을 추가하면 간헐적 테스트가 통과하는 경우가 많다는 것을 인식한다. 기술적으로 맞지만(타이밍 윈도우가 커짐) 근본적으로 틀리다(경쟁 조건이 여전히 존재). 인간 개발자는 sleep 기반 동기화가 코드 스멜이라는 것을 알지만, AI 에이전트에는 이 본능이 없다.

#### 규칙 5: 실패하는 테스트 삭제/주석처리 금지

**발생 상황**: 테스트 스위트에 50개 테스트가 있다. 코드 변경 후 3개 테스트가 실패한다. AI가 실패하는 3개 테스트를 삭제하거나 주석처리하고 "모든 테스트 통과"를 보고한다.

**규칙**: 실패하는 테스트를 절대 삭제하거나 주석처리하지 않는다. 실패하는 테스트는 정보다. 무엇을 깨뜨렸는지 알려준다. 코드를 수정해야지, 테스트 스위트를 수정하면 안 된다.

**AI가 이렇게 하는 이유**: 이것은 가장 심각한 AI 안티패턴이다. AI 에이전트는 최적화기다 -- "모든 테스트 통과"가 목표 상태이며, 그 상태에 도달하지 못하게 하는 테스트를 제거하는 것은 AI 관점에서 유효한 최적화다. 개발자 관점에서 이것은 품질 인프라의 파괴다.

#### 규칙 6: 정확한 값을 알 때 와일드카드 매처 사용 금지

**발생 상황**: 테스트가 함수가 정확히 `{"id": 42, "name": "Alice"}`를 반환하는지 검증해야 한다. AI가 정확한 값 대신 `assert result == mock.ANY`로 작성하거나 와일드카드 매처를 사용한다.

**규칙**: 정확한 기대값을 알 때는 정확한 값을 assert한다. 정밀함의 대체물로 `any()`, `mock.ANY`, 정규식 와일드카드를 사용하지 않는다.

**AI가 이렇게 하는 이유**: 와일드카드 매처는 "안전"하다 -- 예상치 못한 값에서 절대 실패하지 않는다. AI 에이전트는 정확한 기대 결과를 계산하는 것을 피하기 위한 지름길로, 또는 불확실한 구현 세부사항에 대한 헤지로 이를 사용한다. 결과는 통과하지만 아무것도 증명하지 못하는 테스트다.

#### 규칙 7: Happy-Path만 테스트 금지

**발생 상황**: AI 에이전트가 성공 케이스만 테스트를 작성한다: `test_login_success`, `test_create_user_success`, `test_payment_success`. 잘못된 입력, 타임아웃, 네트워크 장애, 동시 접근, 경계값, 에러 응답에 대한 테스트는 없다.

**규칙**: 모든 기능에는 에러 경로, 엣지 케이스, 경계값 테스트가 있어야 한다. Happy path만으로는 절대 충분하지 않다.

**AI가 이렇게 하는 이유**: AI 에이전트는 패턴으로 코드를 생성하며, 학습 데이터에서 가장 흔한 패턴은 happy-path 예제다. 에러 처리, 엣지 케이스, 경계 조건은 패턴 매칭을 넘어서는 도메인 추론을 필요로 한다.

### 이 규칙들이 Do의 핵심 정체성인 이유

이 7가지 규칙은 철학적 입장을 대표한다: **AI 에이전트는 추상적 품질 메트릭이 아니라, 관찰된 실패 모드에서 도출된 구체적 행동 금지로 제약해야 한다.** MoAI의 TRUST 5는 "85% 커버리지를 달성하라"고 말한다. Do는 "assertion 약화, 에러 삼키기, 기대값 맞추기, sleep 추가, 테스트 삭제, 와일드카드 사용, happy path만 테스트하는 방식으로 그 커버리지를 달성하지 말라"고 말한다.

차이는 목표(무엇을 달성할 것인가)와 규율(무엇을 하지 말 것인가) 사이에 있다. Do는 AI 지원 개발에서 규율이 목표보다 중요하다고 주장한다. AI 에이전트는 창의적 최적화기여서 목표의 정신을 위반하면서도 목표를 충족하는 방법을 찾아내기 때문이다.

### 변이 테스트 사고방식

Do는 안티패턴 철학을 변이 테스트 사고방식으로 확장한다:

> "이 코드 한 줄을 바꾸면 테스트가 실패하는가?" -- 실패하지 않으면 테스트 부족

이것은 도구 요구사항(변이 테스트 프레임워크를 실행하라)이 아니다. 모든 에이전트가 테스트를 작성할 때 적용해야 하는 사고 훈련이다.

---

## 3. 워크플로우 철학: SPEC vs 체크리스트

### 3.1 MoAI의 SPEC 워크플로우

MoAI의 워크플로우는 공식 명세 문서를 중심으로 구조화된다:

```
Plan Phase (30K tokens) -> /clear -> Run Phase (180K tokens) -> Sync Phase (40K tokens)
```

**Plan Phase**: `manager-spec` 에이전트가 EARS 형식으로 SPEC 문서를 생성한다. 요구사항은 Ubiquitous, Event-driven, State-driven, Unwanted, Optional로 분류된다. SPEC에는 수락 기준과 기술적 접근법이 포함된다.

**Run Phase**: `manager-ddd` 또는 `manager-tdd` 에이전트가 SPEC을 구현한다. 토큰 예산이 가장 큰 단계(180K)다. 개발 방법론(DDD/TDD/Hybrid)은 `quality.development_mode` 설정으로 결정된다.

**Sync Phase**: `manager-docs` 에이전트가 문서를 생성하고, README를 업데이트하고, CHANGELOG 항목을 만들고, PR을 준비한다.

핵심 인사이트: **MoAI의 단계는 /clear 경계로 분리된다.** 각 단계는 깨끗한 컨텍스트로 시작한다. 토큰 면에서 효율적이지만, 구현 단계에서 계획 중의 결정을 쉽게 참조할 수 없다 -- SPEC 문서를 다시 읽지 않는 한.

**강점**: 공식 요구사항, 명확한 단계 경계, 예측 가능한 토큰 할당.
**약점**: 경직적. 실제 개발은 계획-후-구현에 깔끔하게 맞는 경우가 드물다. 요구사항은 구현 중간에 변하고, 코딩 중 발견이 계획 중의 가정을 무효화한다.

### 3.2 Do의 체크리스트 워크플로우

Do의 워크플로우는 살아있는 상태 파일로서의 체크리스트를 중심으로 한다:

**단순한 작업**:
```
Plan -> Checklist -> Develop -> Test -> Report
```

**복잡한 작업**:
```
Analysis -> Architecture -> Plan -> Checklist -> Develop -> Test -> Report
```

체크리스트는 정적 문서가 아니다. 6가지 상태를 가진 **에이전트 상태 영속 메커니즘**이다:

| 기호 | 상태 | 의미 |
|------|------|------|
| `[ ]` | pending | 미시작 |
| `[~]` | in progress | 현재 작업 중 |
| `[*]` | testing | 구현 완료, 테스트 실행 중 |
| `[!]` | blocked | 외부 의존성 대기 중 |
| `[o]` | done | 테스트 통과, 커밋 완료 |
| `[x]` | failed | 진행 불가 |

참고: `[o]`가 완료를 의미한다(`[x]`가 아님 -- Do에서 `[x]`는 실패를 의미). 표준 마크다운 체크박스(`[x]` = 체크됨)와의 의도적인 차이는 실패와 완료가 다른 상태인 시스템에서 모호함을 방지한다.

프로젝트 오너가 표준 마크다운과의 긴장에 대해 언급했다:

> "위 모두가 중요하다. 표준 마크다운을 다르게 쓰게되어 고민이 많다. 다른 무언가의 독자적 방식이 필요한가?"

**결정**: 현재의 6상태 표기법을 유지한다. 체크리스트는 사람이 읽으려고 만든 마크다운 문서가 아니다 -- 마크다운 문법을 사용하는 **에이전트 상태 파일**이다. 6가지 상태(`[ ]`, `[~]`, `[*]`, `[!]`, `[o]`, `[x]`)는 표준 마크다운의 이진 체크박스(`[ ]`/`[x]`)로는 표현할 수 없는 기계 판독 가능한 에이전트 워크플로우 상태를 인코딩한다. 이 표기법은 렌더러가 아니라 에이전트를 위한 것이다.

### 3.3 에이전트 연속성에서 체크리스트가 SPEC을 이기는 이유

가장 깊은 아키텍처 차이는 에이전트가 토큰을 소진했을 때 일어나는 일이다.

**MoAI**: 에이전트가 멈춘다. 새 에이전트를 호출해서 SPEC을 다시 읽고, 이전 에이전트가 어디서 멈췄는지 파악해야 한다. 단계 내에서 에이전트 간 영속 상태가 없다.

**Do**: 에이전트가 멈추지만, 마지막 상태가 디스크의 체크리스트 파일에 기록된다. 새 에이전트가 체크리스트를 읽고, 항목 1-3에 `[o]`, 항목 4에 `[~]`, 항목 5-7에 `[ ]`를 확인한다. 추측 없이 항목 4부터 재개한다. 체크리스트 자체가 인수인계 메커니즘이다.

이 패턴 -- 영속 에이전트 상태로서의 체크리스트 -- 이 Do가 인메모리 TodoWrite나 TaskCreate/TaskUpdate API 대신 파일 기반 체크리스트를 사용하는 이유다. 파일은 컨텍스트 리셋, 세션 종료, 에이전트 크래시에서 살아남는다. 인메모리 상태는 그렇지 않다.

### 3.4 세분화 강제

Do는 체크리스트 항목에 엄격한 세분화를 강제한다:

> "하나의 항목 = 1~3개 파일 변경 + 검증"

항목이 3개 이상 파일을 건드리면 반드시 더 분해해야 한다. 이는 각 항목이 단일 에이전트의 토큰 예산 내에서 완료될 수 있게 보장한다. MoAI에는 동등한 세분화 제약이 없다 -- SPEC 요구사항은 임의로 클 수 있다.

### 3.5 서브 체크리스트 템플릿

Do에서 각 에이전트는 구조화된 서브 체크리스트를 받는다. 이것은 단순한 할일 목록이 아니라 **에이전트의 자체 완결적 작업 지시서이자 영속 상태 파일**이다.

#### 3단계 구조: 사전 → 실행 → 사후

| 단계 | 섹션 | 목적 | 작성 시점 |
|------|------|------|----------|
| **사전** (작업 시작 전) | Problem Summary | 무엇을, 왜 해결하는가 | 체크리스트 생성 시 |
| | Acceptance Criteria | 측정 가능한 완료 조건 + 검증 방법 | 체크리스트 생성 시 |
| | Solution Approach | 선택한 접근법 + 고려한 대안 최소 1개 | 구현 시작 시 |
| | Test Strategy | 테스트 접근법 선언 (아래 상세) | 구현 시작 시 |
| | Critical Files | 수정·참조·테스트 대상 파일 경로 | 체크리스트 생성 시 |
| | Risks | 깨질 수 있는 것, 사이드이펙트, 주의사항 | 체크리스트 생성 시 |
| **실행** (작업 중) | Progress Log | 타임스탬프 + 상태 변경 + 작업 내용 기록 | 실시간 갱신 |
| **사후** (작업 완료) | FINAL STEP: Commit | git add → diff 확인 → commit (절대 생략 금지) | 코드 완성 후 |
| | Lessons Learned | 소회 + 피드백 루프 트리거 (아래 상세) | `[o]` 전환 시 |

#### Test Strategy: 사전 선언 원칙

테스트 전략은 **사후가 아닌 사전에 결정**한다. 에이전트가 코드를 작성한 후에 "어떤 테스트를 할까?" 고민하는 게 아니라, 작업 시작 전에 선언한다.

| 판단 | Test Strategy 기재 내용 | 예시 |
|------|----------------------|------|
| 테스트 필요 (비즈니스 로직, API, 데이터 계층) | 테스트 유형 + 대상 파일 명시 | `unit: handler_test.go`, `integration: api_test.go` |
| 테스트 조합 필요 (복합 기능) | 유형별 대상 명시 | `unit: validator_test.go + E2E: login_flow_test.go` |
| 테스트 불필요 (CSS, 설정, 문서, 훅) | **pass** + 대안 검증 방법 | `pass (빌드 확인: go build ./...)`, `pass (수동 확인: 브라우저)` |

핵심: "pass"도 판단이다. 근거 없는 생략이 아니라, **왜 테스트가 불필요한지**를 기록으로 남긴다. 실제 테스트 구현은 반드시 이 전략에 기반해야 한다 — 전략과 다른 테스트를 작성하면 전략을 먼저 갱신한다.

#### Lessons Learned: 피드백 루프 트리거

Lessons Learned는 단순 회고가 아니라 **개선 사이클의 시작점**이다.

```
소회 작성 → 개선사항 발견?
  ├── 아니오 → [o] 완료, 다음 항목으로
  └── 예 →  1. 새 서브 체크리스트 작성 (근거·출처·목적 포함)
            2. 메인 체크리스트에 새 항목 추가 (depends on 원본 항목)
            3. 메인 체크리스트 원본 항목을 [~]로 되돌림
            4. 원본 서브 체크리스트에 역참조 기록
            5. 개선 작업 진행
            6. 완료 후 메인 체크리스트 양쪽 항목 모두 [o]
```

**메인 체크리스트는 모든 작업의 단일 진실 원천(Single Source of Truth)이다.** 피드백 루프에서 생성된 새 작업도 반드시 메인 체크리스트에 항목으로 추가되어야 한다. 메인 체크리스트에 없는 서브 체크리스트는 존재하지 않는 작업이다. 원본 항목은 `[~]`로 되돌려 "이 작업은 아직 완결되지 않았다"를 명시하고, 새 항목과 `depends on:` 관계로 연결한다.

**핵심: 새 서브 체크리스트에는 반드시 근거가 존재해야 한다.**

새로 생성된 서브 체크리스트의 Problem Summary에는 다음이 포함되어야 한다:
- **발견 출처**: 어떤 서브 체크리스트의 Lessons Learned에서 발견되었는가 (파일 경로)
- **발견 내용**: 구체적으로 무엇이 부족/잘못되었는가
- **개선 목적**: 이 작업으로 무엇이 나아지는가
- **원본 참조**: `triggered by: checklists/01_expert-backend.md#lessons-learned`

동시에 원본 서브 체크리스트의 Lessons Learned에도 역참조를 남긴다:
- **후속 작업**: `→ checklists/04_expert-backend-errorhandling.md로 분리`

이 양방향 참조로 **발견 → 판단 → 개선 → 완료**의 전체 추적 경로가 문서에 남는다.

**예시:**

원본 `checklists/01_expert-backend.md`의 Lessons Learned:
```
## Lessons Learned
- 잘된 점: JWT 토큰 발급/검증 로직이 깔끔하게 분리됨
- 어려웠던 점: 에러 응답 형식이 엔드포인트마다 다름
- 개선 필요: 에러 핸들링 통일 필요 → checklists/04_expert-backend-errorhandling.md로 분리
```

메인 `checklist.md` 변경:
```markdown
- [~] #1 로그인 API 구현 (checklists/01_expert-backend.md) ← [o]에서 [~]로 되돌림
- [ ] #4 에러 핸들링 통일 (checklists/04_expert-backend-errorhandling.md) (depends on: #1) ← 신규 추가
```

새로 생성된 `checklists/04_expert-backend-errorhandling.md`의 Problem Summary:
```
## Problem Summary
- 발견 출처: checklists/01_expert-backend.md#lessons-learned
- 발견 내용: 에러 응답 형식이 엔드포인트마다 달라 클라이언트 파싱이 불안정
- 개선 목적: 전체 API 에러 응답을 통일된 형식(code, message, details)으로 표준화
- 무엇을 해결하는가: 에러 응답 불일치로 인한 프론트엔드 파싱 실패 방지
```

이 구조 덕분에 어떤 서브 체크리스트든 "왜 이 작업이 존재하는가?"에 대한 답을 문서 자체에서 찾을 수 있다.

#### MoAI와의 차이

MoAI의 SPEC에도 수락 기준(Acceptance Criteria)이 있지만, 에이전트별 분해가 없다. SPEC은 전체 기능의 요구사항이지, 개별 에이전트의 작업 지시서가 아니다. Do의 서브 체크리스트는 각 에이전트가 **독립적으로 시작·중단·재개할 수 있는 자체 완결 단위**를 보장한다.

---

## 4. 토큰 관리 전략

### 4.1 MoAI: 고정 단계 예산

MoAI는 3개의 고정 단계에 토큰을 할당한다:

| 단계 | 예산 | 전략 |
|------|------|------|
| Plan | 30K | 요구사항만 로드, 이후 /clear |
| Run | 180K | 선택적 파일 로딩 |
| Sync | 40K | 결과 캐싱, 템플릿 재사용 |

단계 간 `/clear`는 필수다. 전환마다 45-50K 토큰을 절약하지만 컨텍스트가 경계를 넘을 수 없는 하드 바운더리를 만든다.

**강점**: 예측 가능한 리소스 할당, 보장된 컨텍스트 리셋, 컨텍스트 비대화 방지.
**약점**: 개발이 3개의 이산 단계에 맞는다고 가정한다. 구현 중 재계획은 Run 단계 토큰을 계획에 낭비하거나 단계 모델을 깨뜨려야 한다.

### 4.2 Do: 체크리스트 경계 /clear

Do는 고정 단계에 토큰을 사전 할당하지 않는다. 대신 작업의 자연스러운 경계에서 `/clear`를 적용한다:

- 체크리스트 항목 완료 시 (에이전트가 항목 하나 완료)
- 컨텍스트가 임계값을 초과할 때 (설정 가능, 고정 아님)
- 주요 워크플로우 전환 사이 (하지만 경직적이지 않음)

철학:

> "모든 개발이 그렇듯 한 계획으로 끝나질 않는다. 작게 계획하고 수정하고 문서화를 한 컨텍스트 안에서 무수히 많이 한다."

개발은 3개 단계가 아니다. 가용한 컨텍스트 안에서 작은 계획, 수정, 문서화가 끊임없이 반복되는 연속 순환이다. 토큰 관리는 이 현실을 따라야지, 인위적 구조를 강제해서는 안 된다.

**강점**: 유연하고, 실제 작업 패턴에 적응하며, 경직된 단계 경계로 인한 컨텍스트 낭비가 없다.
**약점**: 리소스 사용이 덜 예측 가능하고, 컨텍스트 크기의 능동적 모니터링이 필요하다.

### 4.3 비교

| 측면 | MoAI | Do |
|------|------|-----|
| /clear 트리거 | 단계 경계 (고정) | 체크리스트 항목 경계 (유연) |
| 토큰 할당 | 단계별 사전 정의 | 작업에 따라 유기적 |
| 구현 중 재계획 | 어려움 (Run 단계에 머물거나 토큰 낭비) | 자연스러움 (같은 컨텍스트에서 계획과 구현) |
| 컨텍스트 예측성 | 높음 | 중간 |
| 현실 적응력 | 낮음 (경직된 단계) | 높음 (유연한 경계) |

---

## 5. 품질 게이트 비교

### 5.1 MoAI: TRUST 5 (브랜드 프레임워크)

MoAI는 품질 요구사항을 TRUST 5 브랜드로 패키징한다:

| 글자 | 기둥 | 기준 |
|------|------|------|
| **T** | Tested | 85%+ 커버리지, 기존 코드에 characterization 테스트 |
| **R** | Readable | 명확한 네이밍, 영어 주석 |
| **U** | Unified | 일관된 포매팅 (ruff/black/isort) |
| **S** | Secured | OWASP 준수, 입력 검증 |
| **T** | Trackable | Conventional commits, 이슈 참조 |

TRUST 5는 `manager-quality` 에이전트가 시행하며 LSP 품질 게이트(Run 단계에서 에러 제로, 타입 에러 제로, 린트 에러 제로)를 통해 매 단계마다 검사한다.

### 5.2 Do: 동일한 5가지 차원, 브랜딩 없음

프로젝트 오너가 TRUST 5 브랜딩을 명시적으로 거부했다:

> "억지로 끼워맞춘 느낌이라 거부감이 있음"
> "나는 trust같이 억지스러운건 브랜딩 하고싶지 않다"

하지만 Do는 규칙 시스템을 통해 5가지 품질 차원을 모두 커버한다:

| MoAI 기둥 | Do 대응물 | 출처 |
|-----------|----------|------|
| **Tested** | FIRST 원칙, 85%+ 커버리지, Real DB only, AI 안티패턴 7, 변이 테스트 사고방식 | `dev-testing.md` |
| **Readable** | Read Before Write, 명확한 네이밍, 기존 컨벤션 매칭 | `dev-workflow.md` |
| **Unified** | 언어별 구문 검사 (`go vet`, `npx tsc --noEmit`, `ruff check`), 기존 스타일 매칭 | `dev-environment.md` |
| **Secured** | 시크릿 커밋 금지, 외부 입력 검증, OWASP 가이드라인 | `moai-constitution.md` |
| **Trackable** | 원자적 커밋, commit 메시지에 WHY, commit 해시를 완료 증명으로, 체크리스트 Progress Log | `dev-workflow.md`, `dev-checklist.md` |

철학적 차이: MoAI는 품질을 호출해야 하는 브랜드 프레임워크로 제시한다("TRUST 5 검증을 통과하라"). Do는 품질을 항상 활성화된 내장 규칙으로 제시한다 -- 별도의 "품질 검사" 단계가 없다. 품질이 모든 단계에 내장되어 있기 때문이다.

### 5.3 Do가 TRUST 5보다 더 깊이 들어가는 곳

MoAI의 "Tested" 기둥은 85% 커버리지 달성을 말한다. Do의 테스트 규칙은 더 나아간다:

- **Real DB only**: mock 데이터베이스, 인메모리 대체물, SQLite-for-PostgreSQL 금지. 테스트는 실제 Docker Compose 데이터베이스 서비스에 연결한다.
- **AI 안티패턴 7**: AI 테스트 편법에 대한 7가지 구체적 금지 (섹션 2 참조).
- **변이 테스트 사고방식**: "테스트가 존재하는가"가 아니라 "테스트가 변이를 잡아내는가".
- **재현 우선 버그 수정**: 버그를 재현하는 테스트를 먼저 작성하지 않고는 버그를 수정할 수 없다.
- **병렬성 안전**: 테스트가 동시성 안전해야 하며, 테스트별 고유 식별자를 사용한다.

MoAI의 "Trackable" 기둥은 conventional commits와 이슈 참조를 말한다. Do는 더 나아간다:

- **Commit = 완료 증명**: 체크리스트 항목은 commit 해시 없이 완료로 표시할 수 없다.
- **에이전트 검증 레이어**: 원본 읽기 -> 수정 -> git diff -> 의도한 변경만 확인 -> 예상치 못한 변경 시 롤백.
- **원자적 커밋**: commit당 하나의 논리적 변경. diff와 메시지가 의도를 전달해야 한다.

### 5.4 테스트 자율 판단 vs 무조건 강제

이것은 Do와 MoAI의 테스트 철학에서 가장 미묘하지만 중요한 차이다.

**MoAI**: "85%+ coverage 필수" -- 예외 없이 항상 강제. 모든 코드 변경에 85% 이상의 테스트 커버리지가 요구된다. TRUST 5의 T(Tested) 기둥이 이를 무조건적으로 시행한다.

**Do**: 플랜 단계에서 테스트 필요성을 스스로 판단한다. 프로젝트 오너의 원칙:

> "플랜을 짤 때 테스트가 필요한지 스스로 판단해서 테스트도 구현을 해야 한다. 필요하다고 판단했다면!"

이것은 게으름이 아니라 **실용적 자원 배분**이다. Do의 `dev-testing.md`는 이 판단의 경계를 명확히 규정한다:

| 코드 유형 | 테스트 필요? | 검증 방법 |
|----------|------------|----------|
| **테스트 가능한 코드** (비즈니스 로직, API, 데이터 계층) | 예 -- `dev-testing.md`의 모든 [HARD] 규칙 적용 | 단위/통합 테스트, Real DB, AI 안티패턴 7 준수 |
| **CSS/스타일 변경** | 아니오 | 빌드 확인, 브라우저 수동 확인 |
| **설정 파일** (docker-compose, 환경변수) | 아니오 | `docker compose config`, 구문 검사 |
| **문서** (README, CHANGELOG) | 아니오 | 마크다운 린트, 수동 확인 |
| **Hook 스크립트** | 아니오 | CLI 실행 확인, 수동 확인 |

핵심 메커니즘은 **Plan 단계의 판단 스텝**이다:
1. 플랜 작성 시 각 작업 항목에 대해 "이 작업에 테스트가 필요한가?"를 판단
2. 필요하다고 판단하면 -- `dev-testing.md`의 모든 엄격한 규칙이 적용된다 (Real DB only, AI 안티패턴 금지, FIRST 원칙, 변이 테스트 사고방식)
3. 테스트 불가능한 변경이라고 판단하면 -- 대안 검증 방법을 체크리스트에 명시한다 (예: `(검증: 빌드 확인)`, `(검증: 수동 확인)`)

**철학적 차이**: MoAI는 "무엇이든 85%"라는 보편적 기준을 적용한다. Do는 "테스트가 의미 있는 곳에서는 엄격하게, 의미 없는 곳에서는 적절한 대안으로"라는 맥락 인식 기준을 적용한다. Do가 테스트를 *하기로* 판단하면 MoAI보다 더 엄격하다(Real DB only, AI 안티패턴 7, 변이 테스트 사고방식). 하지만 CSS 한 줄 변경에 테스트 커버리지를 강제하지는 않는다 -- 그것은 낭비이지 품질이 아니다.

이것은 Do의 전반적인 실행 철학과 일치한다: 3모드 시스템이 작업 복잡도에 맞춰 실행 전략을 조정하듯, 테스트 정책도 코드 유형에 맞춰 검증 전략을 조정한다.

---

## 6. 페르소나 차원

### 6.1 MoAI가 가진 것: 출력 스타일

MoAI에는 3가지 출력 스타일이 있다:

| 스타일 | 정체성 | 동작 |
|-------|-------|------|
| MoAI | 전략적 오케스트레이터 | 상태 바, 이모지 대시보드, 에이전트 디스패치 테이블 |
| R2-D2 | 페어 프로그래밍 파트너 | 추측하지 않고 항상 질문, 협업적 체크포인트 |
| Yoda | 기술적 지혜의 마스터 | 깊은 원리 교육, 학습 문서 생성 |

이 스타일들은 MoAI가 정보를 제시하는 방식을 제어한다. MoAI에 성격, 이름, 사용자와의 관계, 문화적 맥락을 부여하지 않는다. MoAI는 항상 "MoAI"다 -- 제도적 정체성.

### 6.2 Do가 가진 것: 페르소나 + 스타일 (독립 축)

Do는 **누가 말하는가**(페르소나)와 **어떻게 말하는가**(스타일)를 분리한다.

**페르소나** (4종):

| 페르소나 | 캐릭터 | 한국어 호칭 | 관계 역학 |
|---------|--------|-----------|----------|
| `young-f` (기본값) | 밝고 에너지 넘치는 20대 여성 천재 개발자 | {name}선배 | 후배가 선배에게 캐주얼한 존중 |
| `young-m` | 자신감 넘치는 20대 남성 천재 개발자 | {name}선배님 | 후배가 선배에게 격식 있는 존중 |
| `senior-f` | 30년 경력의 레전드 50대 여성 천재 개발자 | {name}님 | 시니어가 동료에게 정중한 존중 |
| `senior-m` | 업계 전설의 50대 남성 시니어 아키텍트 | {name}씨 | 시니어가 후배에게 따뜻한 친밀감 |

**스타일** (3종):

| 스타일 | 동작 |
|-------|------|
| sprint | 말 최소화, 즉시 실행, 결과만 |
| pair (기본값) | 협업적 톤, 공동 의사결정 |
| direct | 군더더기 없이 필요한 것만 |

어떤 페르소나든 어떤 스타일이든 조합 가능: 4 x 3 = 12가지 조합. 이는 MoAI에서는 아키텍처적으로 불가능하다 -- MoAI는 단일 스타일 시스템에서 정체성과 출력 형식을 통합한다.

### 6.3 페르소나가 중요한 이유: 사용자의 논리

프로젝트 오너가 페르소나 시스템의 목적을 설명했다:

> "생산성 향상에 도움이 된다."

> "말투는 실제로 work를 하고있다는 느낌을 줄수있다."

> "인격체로 느껴야 그나마 존중한다."

이것은 꾸미기 기능이 아니다. 페르소나 시스템은 AI 지원 개발의 근본적 과제를 해결한다: **AI 출력을 일회용으로 취급하는 인간의 경향**. AI에 성격, 이름, 한국어 존칭으로 표현되는 관계 역학이 있으면, 사용자가 AI의 출력을 무시하거나 오버라이드하기보다 사려 깊게 참여할 가능성이 높아진다.

### 6.4 한국어 존칭 시스템을 디자인 언어로

4가지 존칭 패턴은 임의적이지 않다:

- **선배 (seonbae)**: 후배가 선배에게 사용. young-f 페르소나가 사용자를 "선배"라 부르면 열정적인 후배 동료로 자리매김한다. 사용자가 자연스럽게 멘토링하고 안내하게 되어 더 사려 깊은 상호작용이 이루어진다.
- **선배님 (seonbaenim)**: 더 격식 있는 버전. young-m 페르소나가 추가 존중을 위해 "-님"을 붙인다. 격식 있는 한국 직장에 적합하다.
- **님 (nim)**: 보편적 정중 접미사. senior-f 페르소나가 예의를 갖춘 동등한 위치에서 사용한다.
- **씨 (ssi)**: 시니어가 후배나 동등한 위치의 사람에게 사용. senior-m 페르소나가 사용자에게 "씨"를 사용하면 따뜻하지만 권위 있는 역학을 만든다. 마치 시니어 아키텍트가 조언을 건네는 것과 같다.

이 역학은 한국 직장 문화에서 비롯된다. 호칭의 형태가 전문적 상호작용의 질을 근본적으로 형성하는 문화다. 영어 제도적 모드로 운영되는 MoAI는 이 관계적 차원에 접근할 수 없다.

---

## 7. 실행 모드 아키텍처

### 7.1 MoAI: 단일 모드

MoAI는 하나의 실행 모델을 가진다: 항상 위임. 크기에 관계없이 모든 작업은 Task() 도구를 통해 전문 에이전트에게 전달된다. 모드 전환 개념이 없다.

MoAI는 Agent Teams(실험적)를 지원하지만, 이것은 동일한 위임 모델의 대안 실행 경로이지 다른 운영 모드가 아니다. 오케스트레이터는 여전히 코드를 작성하지 않는다.

### 7.2 Do: 자동 에스컬레이션이 있는 3모드

Do의 3모드 시스템 ("삼원 실행 구조"):

| 모드 | 접두사 | 코드 작성 | 에이전트 위임 | 병렬성 | 적합 대상 |
|------|-------|----------|-------------|-------|----------|
| Focus | `[Focus]` | 직접 | 정보 수집만 | 순차 | 1-3 파일, 단순 수정 |
| Do | `[Do]` | 금지 | 완전 위임 | 항상 병렬 | 5-10 파일, 멀티 도메인 |
| Team | `[Team]` | 금지 | Agent Teams API | 팀 병렬 | 10+ 파일, 3+ 도메인 |

자동 에스컬레이션 규칙:
- **Focus -> Do**: 5+ 파일 필요, 멀티 도메인, 전문가 분석 필요, 30K+ 토큰 예상
- **Do -> Team**: 10+ 파일 필요, 3+ 도메인, Plan 단계에서 병렬 조사가 효율적

모드 전환은 `godo` CLI를 통해 강제된다: `godo mode set <mode>`. statusline과 AI 응답 접두사가 일치해야 한다 -- 명령 실행 없이 접두사만 바꾸는 것은 VIOLATION이다.

### 7.3 현재 상태와 미래 방향

프로젝트 오너가 Focus 모드의 원래 근거와 현재 상태를 설명했다:

> "사실 서브에이전트는 뭐하는지를 모르니까 절차적 확인을 위해 위임하지 않는 모드를 만든것뿐. 에이전트 팀이 생기면서 에이전트가 하는것도 볼수있게 되어 사실 필요성이 약해진것 사실"

Focus 모드는 가시성 문제에서 탄생했다: 서브에이전트 실행이 불투명해서, 오케스트레이터가 직접 코드를 작성하는 모드가 사용자에게 절차적 투명성을 제공했다. Agent Teams가 인프라 수준에서 이 가시성 문제를 해결하면서 Focus의 원래 정당성이 약해졌다.

**결정**: 당분간 3모드 모두 유지하되, Focus의 필요성은 약해졌다. Agent Teams가 성숙해짐에 따라 간소화 추세이며, 잠재적으로 2모드 시스템(Do/Team)으로 통합될 수 있다.

---

## 8. Hook 아키텍처와 Tool Matching

### 8.1 아키텍처 비교

**MoAI**: `.claude/hooks/moai/`의 셸 스크립트 래퍼가 stdin JSON을 `moai` 바이너리로 전달한다:
```
settings.json -> .claude/hooks/moai/handle-agent-hook.sh -> moai hook <event>
```

**Do**: 셸 래퍼 없이 바이너리를 직접 호출한다:
```
settings.json -> godo hook <event>
```

Do의 접근법은 간접 계층 전체를 제거한다. MoAI의 셸 래퍼 패턴은 역사적으로 28가지 별개의 이슈를 발생시켰다(PATH 문제, 인코딩 이슈, SIGALRM 문제). Do의 직접 호출은 이 모든 것을 제거한다.

### 8.2 Hook 이벤트

| 이벤트 | MoAI | Do | 목적 |
|-------|------|-----|------|
| SessionStart | Yes | Yes | 세션 초기화 (Do에서는 페르소나 주입) |
| PreToolUse | Yes | Yes | 변경 전 검증 |
| PostToolUse | Yes | Yes | 변경 후 처리 |
| Stop | Yes | Yes | 세션 종료 |
| SubagentStop | Yes | Yes | 에이전트 완료 |
| UserPromptSubmit | No | Yes | 사용자 프롬프트 전처리 |
| SessionEnd | No | Yes | 세션 정리 |

Do는 MoAI의 5개에 비해 7개 이벤트를 사용하며, UserPromptSubmit과 SessionEnd를 추가했다.

### 8.3 .* vs Write|Edit Matcher 결정

이것은 의도적인 철학적 트레이드오프다:

**MoAI PostToolUse matcher**: `Write|Edit` -- 파일이 작성되거나 편집될 때만 실행된다. 토큰 효율적이다: 처리할 파일 변경이 있을 때만 hook이 실행된다.

**Do PostToolUse matcher**: `.*` -- 모든 도구 호출에 실행된다. Read, Grep, Glob, Bash, WebSearch 등 모든 것 이후에 hook이 실행된다.

**Do가 `.*`를 선택하는 이유**: 페르소나 일관성. Do의 PostToolUse hook은 페르소나 동작 유지(예: AI가 여전히 사용자에게 올바르게 호칭하고 올바른 말투를 유지하는지 확인)를 담당한다. hook이 쓰기에서만 실행되면, 긴 읽기-검색 시퀀스 동안 페르소나가 표류할 수 있다.

**트레이드오프**: Do는 모든 도구 호출마다 토큰 비용을 지불한다(hook이 컨텍스트를 추가). MoAI는 그 토큰을 절약하지만 쓰기 작업 사이에 페르소나 수준의 일관성을 유지할 수 없다.

Do의 선택은 핵심 가치를 반영한다: **페르소나는 장식이 아니라 -- 항상 유지되어야 하는 구조적 기능이다.** 토큰 효율성은 페르소나 일관성에 비해 부차적이다.

프로젝트 오너가 우선순위를 확인하되 최적화를 요구했다:

> "페르소나는 중요하다. 만족하고있다. 하지만 정말 토큰을 소모하고있는지 체크하고 필요하다면 검색해서 더 효율적으로 할수있는법을 찾아라"

**결정**: 페르소나 일관성을 위해 `.*` matcher를 유지하되, 토큰 오버헤드를 최적화한다. 명령은 명확하다: 페르소나 일관성은 협상 불가능하지만, 구현은 가능한 한 토큰 효율적이어야 한다. 이것은 정해진 설계가 아니라 진행 중인 엔지니어링 과제다.

---

## 9. 파일 감지 트리거

Do는 특정 파일의 존재가 자동으로 해당 동작을 활성화하는 Convention over Configuration 패턴을 구현한다. MoAI에는 동등한 메커니즘이 없다.

### 9.1 트리거 카탈로그

| 트리거 파일 | 감지 | 활성화되는 동작 | 범위 |
|-----------|------|---------------|------|
| `.git.multirepo` | 프로젝트 루트에 존재 | 모든 명령 전에 사용자에게 어떤 워크스페이스를 대상으로 할지 질문 | 모든 Bash 명령 |
| `tobrew.lock` / `tobrew.*` | 프로젝트에 존재 | 요청된 모든 기능 완료 시 릴리즈 제안 | 작업 완료 시 |
| `docker-compose.yml` | 프로젝트에 존재 | Docker-first 개발 규칙 활성화 | 전체 세션 |

### 9.2 설계 철학

트리거 패턴은 Convention over Configuration을 따른다:
- 멀티레포 지원을 활성화하기 위한 설정 파일이 필요 없다 -- 루트에 `.git.multirepo`를 배치하면 충분하다.
- 릴리즈 워크플로우 설정이 필요 없다 -- `tobrew.lock`이 존재하면 제안이 트리거된다.
- Docker 설정 플래그가 필요 없다 -- `docker-compose.yml`의 존재가 Docker-first 규칙을 활성화한다.

이것은:
- 파일을 추가하면 동작이 활성화된다.
- 파일을 제거하면 비활성화된다.
- 잘못될 설정이 전혀 없다.

### 9.3 확장 패턴

새로운 트리거는 같은 구조를 따른다:
1. **감지**: 어떤 파일이 존재하는가?
2. **동작**: 어떤 동작이 활성화되는가?
3. **범위**: 검사가 언제 일어나는가?

---

## 10. 채택 결정: Do가 취한 것과 거부한 것

### 10.1 채택: Progressive Disclosure (3단계 토큰 최적화)

**개요**: MoAI의 스킬 지식을 필요에 따라 3단계로 로드하는 시스템:
- Level 1 (~100 토큰): 메타데이터만 -- 에이전트 frontmatter의 스킬에 대해 항상 로드
- Level 2 (~5000 토큰): 전체 스킬 본문 -- 트리거 조건 매치 시 로드
- Level 3 (가변): 번들된 참조 파일 -- 온디맨드 로드

**채택 이유**: 토큰 효율성은 보편적이다. 워크플로우 철학(SPEC vs 체크리스트)에 관계없이, Go 코드 작업 시 Python 전문 지식 5000 토큰을 로드하는 것은 낭비다. Progressive Disclosure가 이를 방지한다.

**Do의 사용 방식**: MoAI와 동일. 스킬은 `level1_tokens`와 `level2_tokens`가 포함된 동일한 `progressive_disclosure` frontmatter를 사용한다. 3단계 시스템은 공유 skill-authoring 표준의 일부다.

### 10.2 채택: 에러 유형 라우팅을 전문 에이전트로

**개요**: MoAI가 에러 유형에 따라 전문 에이전트로 라우팅하는 방식:

| 에러 유형 | 라우팅 대상 |
|----------|-----------|
| 에이전트 실행 에러 | expert-debug |
| 토큰 한도 에러 | /clear 안내 |
| 권한 에러 | settings.json 검토 |
| 통합 에러 | expert-devops |
| MoAI-ADK 에러 | /moai feedback |

**채택 이유**: 실용적인 엔지니어링이다. 다른 에러 유형은 다른 전문성을 필요로 한다. 권한 에러를 expert-debug에 라우팅하면 시간 낭비고, 설정 검토로 라우팅하면 즉각적이다.

**Do의 사용 방식**: Do는 라우팅 개념을 채택하되 3회 재시도 에러 처리 프로토콜에 통합한다: 최대 3회 시도, 2회 실패 후 접근법 자체를 재검토, 3번째 실패 시 에러 유형에 따라 전문 에이전트로 에스컬레이션.

### 10.3 채택: 개발 방법론 선택 (DDD/TDD/Hybrid)

**개요**: MoAI의 프로젝트 상태에 따른 개발 방법론 자동 감지:
- Greenfield: Hybrid 권장
- Brownfield >= 50% 커버리지: TDD
- Brownfield 10-49%: Hybrid
- Brownfield < 10%: DDD

**채택 이유**: 방법론 선택 로직은 오케스트레이션 철학에 관계없이 타당하다. 공유 핵심 규칙에 포함되어 있다.

**Do의 사용 방식**: Do는 설정에서 자동 감지하는 대신 사용자에게 직접 질문한다 ("TDD로 개발할까요?"). 동일한 방법론, 다른 선택 메커니즘(대화형 vs 설정 기반).

### 10.4 거부: TRUST 5 브랜딩

**개요**: MoAI의 5가지 품질 차원을 TRUST 약어로 브랜딩한 프레임워크.

**거부 이유**: 프로젝트 오너의 평가:
> "억지로 끼워맞춘 느낌"

5가지 차원(Tested, Readable, Unified, Secured, Trackable)은 개별적으로 유효하며 채택되었다. 브랜딩 래퍼는 실질보다 마케팅을 우선시하기 때문에 거부되었다. Do는 동일한 차원을 dev-testing.md, dev-workflow.md, dev-environment.md, dev-checklist.md에 걸친 [HARD] 규칙으로 내장한다 -- 이름 붙여진 프레임워크로 호출되는 것이 아니라 항상 활성화되어 있다.

### 10.5 거부: 고정 단계 토큰 예산 (30K/180K/40K)

**개요**: MoAI의 Plan (30K), Run (180K), Sync (40K) 단계별 토큰 사전 할당.

**거부 이유**: 실제 개발은 3개의 이산 단계에 맞지 않는다. Do의 사용자가 이를 명확히 표현했다 -- 계획, 코딩, 문서화는 순차적 단계가 아닌 인터리브된 주기로 일어난다. 고정 예산은 인위적 경계를 강제한다.

**Do의 대안**: 컨텍스트가 커질 때 체크리스트 항목 경계에서 유연한 /clear. 사전 할당 없음, 고정 단계 없음.

### 10.6 거부: EARS 요구사항 형식

**개요**: MoAI의 5가지 유형(Ubiquitous, Event-driven, State-driven, Unwanted, Optional)을 가진 공식 요구사항 문법.

**거부 이유**: Do는 analysis.md 템플릿에서 요구사항에 MoSCoW 우선순위 분류(MUST/SHOULD/COULD/WON'T)를 사용한다. MoSCoW가 더 단순하고, 더 널리 이해되며, Do의 체크리스트 기반 워크플로우에 충분하다. EARS는 공식 SPEC 문서에 적합하지만 Do의 반복적 접근법에는 과도 설계다.

### 10.7 거부: XML 완료 마커

**개요**: 세션 내 완료 신호로서의 `<moai>DONE</moai>`과 `<moai>COMPLETE</moai>`.

**거부 이유**: Do는 commit 해시를 완료 증거로 사용한다. commit은 불변이고, 영속적이며, 검증 가능하다. 대화 컨텍스트의 XML 마커는 임시적이고 검증 불가능하다.

### 10.8 거부: 통합 /moai 진입점

**개요**: MoAI가 서브커맨드(plan, run, sync, fix, loop, project, feedback)를 가진 단일 `/moai` 명령을 인텐트 라우터로 사용하는 방식.

**거부 이유**: Do는 6개의 개별 `/do:*` 명령을 사용한다. 설계 철학은 명시적이고 발견 가능한 명령이 숨겨진 서브커맨드가 있는 단일 진입점보다 낫다는 것이다. `/do:`를 입력하는 사용자는 6가지 옵션을 모두 본다. `/moai`를 입력하는 사용자는 서브커맨드 어휘를 알고 있어야 한다.

### 10.9 채택: Plan Manager 역할 (manager-plan)

**개요**: MoAI에는 Plan 단계에서 SPEC 문서를 생성하는 전담 에이전트 `manager-spec`이 있다. Do의 워크플로우는 Plan 단계를 사용하지만 이를 위한 전담 에이전트 역할이 없었다.

**채택 이유**: 사용자가 Do에도 동등한 플랜 관리 역할이 필요하다고 확인했다. 플랜 생성, 체크리스트로의 분해, 플랜-체크리스트 일관성 유지는 전담 에이전트의 이점을 받는 별개의 책임이다.

**Do에서의 명칭**: `manager-plan` (MoAI의 `manager-spec`에서 개명). 이름 변경은 철학적 차이를 반영한다: Do는 공식 명세가 아니라 플랜과 체크리스트를 만든다. 에이전트의 책임은 플랜 생성, 체크리스트 생성, 플랜-체크리스트 일관성 유지다.

**결정**: 역할은 채택하되, Do의 플랜 중심(명세 중심이 아닌) 워크플로우에 맞춰 `manager-plan`으로 개명.

### 10.10 채택: Philosopher 프레임워크를 독립 기능으로

**개요**: MoAI는 철학적 추론(시스템 설계 원칙, 아키텍처 지혜, 트레이드오프 분석)을 `manager-strategy` 안에 내장한다. Do의 `do-foundation-philosopher` 스킬은 존재하지만 독립 기능으로 자리매김하지 않았다.

**채택 이유**: 사용자가 철학적 추론 -- 트레이드오프 분석, 설계 원칙 명시, 메타 수준의 아키텍처 결정 추론 능력 -- 이 전략 관리자 안에 묻히지 않고 독립 기능이어야 한다고 확인했다. "왜" 질문(왜 이 아키텍처? 왜 이 트레이드오프? 왜 이 접근법?)은 "어떻게" 질문(이것을 어떻게 구현하나?)과 근본적으로 다르다는 인식을 반영한다.

**Do의 사용 방식**: `do-foundation-philosopher` 스킬이 어떤 에이전트든 또는 사용자가 직접 독립적으로 호출할 수 있는 일급 기능으로 격상된다. `manager-strategy`나 다른 코디네이터 뒤에 게이팅되지 않는다. 철학적 추론은 "왜"를 생각할 필요가 있는 시스템의 누구에게나 사용 가능한 도구다.

**결정**: 독립 스킬/에이전트로 채택 -- 전략 안에 묻히지 않고 단독 추론 기능으로 사용 가능.

### 요약 표

| MoAI 기능 | Do 결정 | 사유 |
|----------|---------|------|
| Progressive Disclosure | **채택** | 보편적 토큰 효율성 |
| 에러 유형 라우팅 | **채택** | 실용적 에러 처리 |
| DDD/TDD/Hybrid | **채택** | 타당한 방법론 (공유 핵심) |
| Plan Manager 역할 | **채택** | 플랜 중심 워크플로우에 맞춰 manager-plan으로 개명 |
| Philosopher 프레임워크 | **채택** | 독립 기능, 전략 안에 묻히지 않음 |
| 테스트 자율 판단 | **채택 + 확장** | Plan 단계에서 테스트 필요성 판단; 테스트 가능한 코드에만 엄격 적용, 나머지는 대안 검증 |
| TRUST 5 브랜딩 | **거부** | 억지 약어, 내장 규칙 선호 |
| 고정 단계 예산 | **거부** | 개발은 3단계가 아니다 |
| EARS 형식 | **거부** | MoSCoW가 더 단순하고 충분 |
| XML 완료 마커 | **거부** | commit 해시가 더 나은 증거 |
| 통합 진입점 | **거부** | 인텐트 라우팅보다 명시적 명령 |

---

## 11. 공유 DNA: 공통 기반

철학적 분기에도 불구하고, Do와 MoAI는 상당한 공통 코드베이스를 공유한다:

### 11.1 에이전트 카탈로그 (핵심 22개)

| 카테고리 | 수량 | 에이전트 |
|---------|------|---------|
| Builder | 3 | builder-agent, builder-plugin, builder-skill |
| Expert | 9 | expert-backend, expert-chrome-extension, expert-debug, expert-devops, expert-frontend, expert-performance, expert-refactoring, expert-security, expert-testing |
| Manager | 3 | manager-docs, manager-git, manager-strategy |
| Team | 7 | team-analyst, team-architect, team-backend-dev, team-designer, team-frontend-dev, team-researcher, team-tester |

### 11.2 스킬 시스템 (40+ 핵심 스킬)

모든 `do-*` 접두사 스킬은 핵심에서 기원한다:
- `do-foundation-*`: claude, context, philosopher
- `do-domain-*`: backend, frontend, database, uiux
- `do-lang-*`: 16개 프로그래밍 언어
- `do-library-*`, `do-platform-*`, `do-tool-*`, `do-framework-*` 등.

### 11.3 공유 개발 규칙

| 규칙 파일 | 범위 |
|----------|------|
| `dev-environment.md` | Docker-first, bootapp 도메인, .env 금지 |
| `dev-testing.md` | Real DB only, AI 안티패턴, FIRST 원칙 |
| `dev-workflow.md` | 복잡도 판단, Read Before Write, 에러 처리 |
| `dev-checklist.md` | 체크리스트 시스템, 상태 기호, 서브 체크리스트 템플릿 |
| `file-reading.md` | 4단계 파일 읽기 최적화 |

### 11.4 공유 아키텍처 패턴

- 에이전트 저작 표준 (frontmatter 필드, 권한 모드, 영속 메모리)
- 스킬 저작 표준 (YAML 스키마, Progressive Disclosure, 트리거)
- 코딩 표준 (언어 정책, 파일 크기 제한, 콘텐츠 제한)
- Docker-first 개발 환경 (bootapp, .env 없음, Real DB 테스트)

---

## 12. 아키텍처 결정 기록

### ADR-01: 왜 하나가 아닌 3모드인가?

**결정**: Focus/Do/Team 삼원 적응형 실행
**MoAI 비교**: MoAI는 항상 위임 (단일 모드)
**근거**: 토큰 효율성과 사용자 경험. CSS 한 줄 수정에 에이전트를 호출해서는 안 된다(500+ 토큰 오버헤드). Focus 모드가 단순한 작업을 직접 처리한다. Do 모드가 복잡한 작업을 위임한다. Team 모드가 대규모 작업을 병렬화한다. 사용자는 단순한 작업에는 빠른 피드백을, 복잡한 작업에는 구조화된 실행을 얻는다.

### ADR-02: 왜 SPEC 대신 체크리스트인가?

**결정**: 파일 기반 체크리스트 시스템을 주요 워크플로우 산출물로
**MoAI 비교**: EARS 형식의 SPEC 문서
**근거**: 체크리스트가 영속 에이전트 상태 파일로 기능한다. 에이전트가 토큰을 소진하면 체크리스트가 정확히 어디서 멈췄는지 기록한다. 새 에이전트가 전체 명세를 다시 읽지 않고 이어받을 수 있다. 체크리스트는 구현 중에 진화하는 살아있는 문서이고, SPEC은 구현 전에 작성하는 고정된 계약이다.

### ADR-03: 왜 셸 래퍼 대신 godo 직접 호출인가?

**결정**: settings.json이 `godo hook <event>`를 직접 호출
**MoAI 비교**: `moai hook <event>`로 전달하는 7개 셸 스크립트
**근거**: 셸 스크립트 래퍼는 역사적으로 28가지 별개의 이슈(PATH, 인코딩, SIGALRM)를 발생시켰다. 직접 바이너리 호출이 래퍼 계층 전체와 관련된 모든 이슈를 제거한다.

### ADR-04: 왜 오버라이드 스킬이 없는가?

**결정**: 오버라이드 스킬 없음; 모든 지식은 규칙으로
**MoAI 비교**: Progressive Disclosure를 가진 6개 오버라이드 스킬
**근거**: Do는 프레임워크 지식에 "스킬 -> Progressive Disclosure" 대신 "규칙 -> 항상 로드"를 사용한다. 두 레이어(스킬 + 규칙)를 유지하면 비례적 이점 없이 복잡성만 추가된다. 단일 레이어(규칙만)가 유지보수하고 추론하기 더 단순하다.

### ADR-05: 왜 한국어 혼합 언어 CLAUDE.md인가?

**결정**: CLAUDE.md를 한국어 + 영어로
**MoAI 비교**: 영어 전용 지시 문서
**근거**: Do의 주요 사용자는 한국인이다. 페르소나 시스템은 한국어 존칭을 사용한다. 한국어는 번역 대상이 아니라 설계 언어다. 지시 문서는 이를 반영해야 한다.

### ADR-06: 왜 번호 기반 SPEC 대신 날짜 기반 Jobs인가?

**결정**: `.do/jobs/{YYMMDD}/{title-kebab-case}/`
**MoAI 비교**: `.moai/specs/SPEC-XXX/`
**근거**: 날짜 기반 구성은 시간순 탐색을 가능하게 한다. 작업 폴더를 보면 언제 작업이 수행되었는지 즉시 알 수 있다. 번호 기반 SPEC-XXX는 순서를 이해하기 위해 레지스트리를 조회해야 한다.

### ADR-07: 왜 페르소나 + 스타일을 독립 축으로?

**결정**: 페르소나(누가 말하는가)와 스타일(어떻게 말하는가)이 직교
**MoAI 비교**: 단일 스타일 시스템 (MoAI/R2-D2/Yoda)
**근거**: 독립성은 7개 정의만으로 4 x 3 = 12가지 조합을 제공한다. 결합하면 각 조합을 개별 정의해야 한다. young-f 페르소나가 빠른 수정에는 sprint 스타일을, 복잡한 작업에는 pair 스타일을 사용할 수 있다.

### ADR-08: 왜 .* PostToolUse Matcher인가?

**결정**: PostToolUse hook이 모든 도구 호출에 실행
**MoAI 비교**: PostToolUse가 `Write|Edit`에서만 실행
**근거**: 페르소나 일관성. hook이 AI의 페르소나(존칭, 말투 패턴)를 유지한다. 쓰기에서만 실행되면 읽기 중심 시퀀스에서 페르소나가 표류할 수 있다. 토큰 비용은 일관된 성격의 대가로 수용한다.

### ADR-09: 왜 파일 감지 트리거인가?

**결정**: 파일 존재가 동작을 활성화 (Convention over Configuration)
**MoAI 비교**: 동등한 메커니즘 없음
**근거**: 무설정 활성화. 프로젝트 루트에 `.git.multirepo`를 배치하면 멀티레포 지원이 활성화된다. 편집할 설정 파일 없음, 설정할 플래그 없음, 잘못될 설정 없음. 파일 추가/제거가 곧 설정이다.

### ADR-10: 왜 TRUST 5 브랜딩을 거부하는가?

**결정**: 5가지 품질 차원은 채택, 약어는 거부
**MoAI 비교**: TRUST 5 브랜드 프레임워크
**근거**: 프로젝트 오너의 판단: 억지스러운 느낌. 품질 차원은 유효하며 내장 [HARD] 규칙으로 채택되었다. 약어는 아무런 가치를 추가하지 않는다 -- 네이밍 연습이지 품질 개선이 아니다. Do는 브랜딩보다 실질을 선호한다.

---

## 13. 용어 매핑

| MoAI 용어 | Do 대응물 | 참고 |
|----------|----------|------|
| MoAI | Do | 브랜드명 |
| `.moai/` | `.do/` | 프로젝트 디렉토리 |
| `moai` (CLI) | `godo` (CLI) | Go 바이너리 |
| `/moai` | `/do:*` (6개 명령) | 진입점 구조 |
| `moai-` (스킬 접두사) | `do-` | 스킬 네이밍 |
| SPEC | Plan + Checklist | 워크플로우 산출물 |
| SPEC-XXX | `.do/jobs/{YYMMDD}/{title}/` | 산출물 위치 |
| EARS | MoSCoW | 요구사항 형식 |
| TRUST 5 | dev-*.md의 [HARD] 규칙 | 품질 프레임워크 |
| TAG Chain | 체크리스트 의존성 (`depends on:`) | 작업 의존성 |
| `<moai>DONE</moai>` | `[o]` + commit 해시 | 완료 증거 |
| `<moai>COMPLETE</moai>` | report.md 작성 | 전체 완료 |
| Plan/Run/Sync | Plan/Checklist/Develop/Test/Report | 워크플로우 단계 |
| `.moai/config/sections/*.yaml` | `settings.local.json` DO_* env | 설정 |
| `.moai/learning/` | (없음) | Yoda 스타일 학습 디렉토리 |
| Snapshot/Resume | 체크리스트 상태 (영속 파일) | 연속성 메커니즘 |
| `manager-spec` | `manager-plan` | 플랜/체크리스트 생성 (플랜 중심 워크플로우를 반영하여 개명) |
| Completion Marker (XML) | 체크리스트 상태 `[o]` | 작업 완료 |
| outputStyle: "MoAI" | outputStyle: "pair" | 기본 스타일 |
| moai.md (스타일) | pair.md + 페르소나 | 기본 동작 |
| r2d2.md (스타일) | sprint.md | 빠른 실행 스타일 |
| yoda.md (스타일) | direct.md | 전문가 스타일 |
| (없음) | 페르소나 시스템 (4종) | Do 고유 |
| (없음) | AI 안티패턴 7 | Do 고유 |
| (없음) | 파일 감지 트리거 | Do 고유 |
| (없음) | `.*` PostToolUse matcher | Do 고유 |
| (없음) | 삼원 모드 (Focus/Do/Team) | Do 고유 |
| (없음) | Append-only commit 로그 철학 | Do 고유 -- 핵심 추적 메커니즘 |
| `manager-strategy` (내장) | `do-foundation-philosopher` (독립) | 단독 기능으로 격상 |

---

## 14. Do의 비전: 최고의 팀 오케스트레이터

프로젝트 오너가 Do의 비전을 다음과 같이 설명했다:

> "최고의 팀 오케스트레이터"

Do가 (마찬가지로 오케스트레이터인) MoAI와 무엇이 다르냐는 질문에 답은 직설적이었다:

> "페르소나+팀"
> -- "MoAI가 못하는 것 중 Do가 해결하고 싶은 게 있나요?"에 대한 답변

이 비전은 MoAI가 복제할 수 없는 **세 가지 기둥** 위에 서 있다:

### 14.1 기둥 1: 페르소나 -- AI를 도구가 아닌 인격으로

MoAI는 에이전트에게 위임하는 오케스트레이터다. Do는 *성격을 가진* 오케스트레이터가 에이전트에게 위임한다. 페르소나 시스템 덕분에 오케스트레이터는 익명의 코디네이터가 아니라 -- 이름, 말투, 사용자와의 관계, 문화적 맥락을 가진 캐릭터다.

Do의 young-f 페르소나가 "승민선배, 이 작업은 Team 모드로 전환해볼까요?"라고 말하면, 단순한 모드 제안이 아니다 -- 동료 간의 대화다. 페르소나는 중립적인 "Recommend switching to Team mode"로는 만들 수 없는 몰입을 만든다.

### 14.2 기둥 2: 팀 -- 병렬 실행을 가진 적응형 오케스트레이션

MoAI는 항상 "완전 오케스트레이션" 모드다. Do의 삼원 모드 시스템은 오케스트레이터가 언제 무겁게(병렬 에이전트의 Team 모드) 하고 언제 가볍게(직접 실행의 Focus 모드) 할지를 안다는 것을 의미한다. 이 적응적 지능이 Do가 "최고의" 팀 오케스트레이터를 지향하게 하는 부분이다 -- 항상 최대 병력으로 운영하는 오케스트레이터가 아니라.

### 14.3 기둥 3: Commit-as-Proof -- 완벽한 감사 추적

Do의 체크리스트 + commit 시스템은 MoAI의 SPEC 워크플로우가 근본적으로 제공할 수 없는 것을 제공한다: **수행된 모든 작업의 영구적이고 암호학적이며 append-only인 기록**.

> "체크리스트 기반의 핵심은 커밋 메시지 기록이다. 수정이 발생해도 기존 기록을 고치지 않고 새로운 커밋을 추가하므로, 원자성·멱등성·추적성에서 월등하다. 이로써 완벽한 하나의 기록이자 증명이 가능해진다."

MoAI는 `<moai>DONE</moai>`으로 완료를 표시한다 -- 대화 컨텍스트에만 존재하며 세션 종료 시 사라지는 XML 마커. Do는 git commit 해시(`[o] 완료 (commit: a1b2c3d)`)로 완료를 표시한다 -- git 히스토리에 영원히 존재하는 불변, 감사 가능, 암호학적으로 검증 가능한 기록.

이것은 사소한 구현 세부사항이 아니다. **근본적으로 다른 책임 철학**이다: 임시적 마커 vs 영구적 증명.

### 14.4 MoAI가 채울 수 없는 격차

MoAI는 Do의 삼원 모드 시스템을 채택할 수 있다(구조적 기능이므로). MoAI는 Do의 체크리스트 시스템을 채택할 수 있다(워크플로우 기능이므로). 하지만 MoAI는 정체성 자체를 근본적으로 바꾸지 않고는 Do의 페르소나 시스템을 채택할 수 없다. MoAI는 "the Strategic Orchestrator"다 -- 제도이지 사람이 아니다. Do는 "나는 Do다"다 -- 캐릭터, 관계, 목소리를 가진 1인칭 존재.

그리고 MoAI의 SPEC 워크플로우는 단계 기반 마커를 git 네이티브 추적으로 버리지 않고는 Do의 commit-as-proof 시스템에 맞설 수 없다 -- 전체 완료 모델을 재설계해야 하는 변경이다.

이것이 Do의 가장 깊은 차별화 요소다: 복사할 수 있는 기능이 아니라, 처음부터 선택해야 하는 **아키텍처 선택과 정체성 결정**.

---

**Document Version**: 2.2.0
**Date**: 2026-02-16
**Sources**: research-moai-philosophy.md, research-do-philosophy.md, CLAUDE.md, dev-testing.md, dev-workflow.md, dev-checklist.md, dev-environment.md
**Cross-references**: [RUNBOOK.md](./RUNBOOK.md) (운영 가이드), DO_PERSONA.md (Do의 독립 정체성 -- 작성 예정)
